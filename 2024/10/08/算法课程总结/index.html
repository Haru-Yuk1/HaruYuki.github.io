<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>春天的雪，静谧的诗 | 春天的雪，静谧的诗</title><meta name="author" content="HaruYuki"><meta name="copyright" content="HaruYuki"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="算法课程总结一、异或运算可以理解为无进位相加eg: a&#x3D;10110 b&#x3D;00111 a^b&#x3D;10001 性质： (1)a^0&#x3D;a a^a&#x3D;0 (2)满足交换律和结合律 (3)跟异或顺序无关，(2)推出的 &#x3D;&#x3D;异或运算可以用来实现两个数之间交换&#x3D;&#x3D;：  注意：a,b值可以一样，但&#x3D;&#x3D;指向的地">
<meta property="og:type" content="article">
<meta property="og:title" content="春天的雪，静谧的诗">
<meta property="og:url" content="https://haru-yuk1.github.io/MyBlog/2024/10/08/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="春天的雪，静谧的诗">
<meta property="og:description" content="算法课程总结一、异或运算可以理解为无进位相加eg: a&#x3D;10110 b&#x3D;00111 a^b&#x3D;10001 性质： (1)a^0&#x3D;a a^a&#x3D;0 (2)满足交换律和结合律 (3)跟异或顺序无关，(2)推出的 &#x3D;&#x3D;异或运算可以用来实现两个数之间交换&#x3D;&#x3D;：  注意：a,b值可以一样，但&#x3D;&#x3D;指向的地">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://haru-yuk1.github.io/MyBlog/img/meguru.jpg">
<meta property="article:published_time" content="2024-10-08T13:25:41.523Z">
<meta property="article:modified_time" content="2024-06-04T11:42:16.272Z">
<meta property="article:author" content="HaruYuki">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://haru-yuk1.github.io/MyBlog/img/meguru.jpg"><link rel="shortcut icon" href="/MyBlog/img/favicon.png"><link rel="canonical" href="https://haru-yuk1.github.io/MyBlog/2024/10/08/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/MyBlog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/MyBlog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '春天的雪，静谧的诗',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-04 19:42:16'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/MyBlog/"><span class="site-name">春天的雪，静谧的诗</span></a><a class="nav-page-title" href="/MyBlog/"><span class="site-name">春天的雪，静谧的诗</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">无标题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-08T13:25:41.523Z" title="发表于 2024-10-08 21:25:41">2024-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-04T11:42:16.272Z" title="更新于 2024-06-04 19:42:16">2024-06-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="算法课程总结"><a href="#算法课程总结" class="headerlink" title="算法课程总结"></a>算法课程总结</h1><h2 id="一、异或运算可以理解为无进位相加"><a href="#一、异或运算可以理解为无进位相加" class="headerlink" title="一、异或运算可以理解为无进位相加"></a>一、异或运算可以理解为无进位相加</h2><p>eg: a&#x3D;10110 b&#x3D;00111 a^b&#x3D;10001</p>
<p>性质：</p>
<p>(1)a^0&#x3D;a a^a&#x3D;0</p>
<p>(2)满足交换律和结合律</p>
<p>(3)跟异或顺序无关，(2)推出的</p>
<p>&#x3D;&#x3D;异或运算可以用来实现两个数之间交换&#x3D;&#x3D;：</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20230919192808241-17015066230472.png" alt="image-20230919192808241"></p>
<p>注意：a,b值可以一样，但&#x3D;&#x3D;指向的地址&#x3D;&#x3D;必须不一样，在数组中，a[i]和a[j] i和j一定不能一样，不然会变成0</p>
<p>eg：</p>
<p><font size="4"><strong>给一个整型数组，（1）其中一种数出现的次数为奇数次，其他数出现次数为偶数次，找到这个数（2）其中两种数出现次数为奇数次，其他数出现次数为偶数次，找到这个数</strong></font></p>
<p><strong>(1)准备一个变量 int eor&#x3D;0，让他遍历异或，最后得到的eor便是该数。</strong></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20230919193900214.png" alt="image-20230919193900214"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一种数出现次数位奇数次，其他数出现次数位偶数次的数组，找到这个数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printOddTimesNum1</span>(<span class="params">arr</span>):</span><br><span class="line">    eor=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        eor^=i</span><br><span class="line">    <span class="built_in">print</span>(eor)</span><br></pre></td></tr></table></figure>

<p><strong>(2)第一步遍历异或一遍，可得到eor&#x3D;a^b,肯定eor!&#x3D;0,则可找到一个位置为1，然后再遍历一遍找这个位置是一的奇数次的数即可</strong></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20230919200127980.png" alt="image-20230919200127980"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#其中两种数出现次数位奇数次，其他数出现次数为偶数次，找到这两个数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printOddTimesNum2</span>(<span class="params">arr</span>):</span><br><span class="line">    eor=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        eor^=i</span><br><span class="line">    rightone=eor&amp;(~eor+<span class="number">1</span>) <span class="comment">#提取出最右的1，比如eor=1010111100 则~eor=01010000100,~eor+1=01010001,eor&amp;(~eor+1)=0000000100</span></span><br><span class="line">    onlyone=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">if</span> i&amp;rightone==<span class="number">0</span>:</span><br><span class="line">            onlyone^=i</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;onlyone&#125;</span>和<span class="subst">&#123;onlyone^eor&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思考：如果奇数次3种，4种呢，如果偶数次1次，2次呢？</p>
<p>答：偶数可以用同或，奇数次多种暂时没想出来</p>
<h2 id="二、各种排序算法"><a href="#二、各种排序算法" class="headerlink" title="二、各种排序算法"></a>二、各种排序算法</h2><h3 id="基于比较的排序"><a href="#基于比较的排序" class="headerlink" title="基于比较的排序"></a>基于比较的排序</h3><h3 id="1-选择排序——时间复杂度：-O-N-2-、空间复杂度：-O-1"><a href="#1-选择排序——时间复杂度：-O-N-2-、空间复杂度：-O-1" class="headerlink" title="1.选择排序——时间复杂度：$O(N^2)$、空间复杂度：$O(1)$"></a>1.选择排序——时间复杂度：$O(N^2)$、空间复杂度：$O(1)$</h3><blockquote>
<p>遍历数组找到最小值并放到开头，接着再找下一个。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210509190545640.gif" alt="在这里插入图片描述"></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selectionSort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> arr==[] <span class="keyword">or</span> <span class="built_in">len</span>(arr)&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-<span class="number">1</span>):<span class="comment"># 0~N-1</span></span><br><span class="line">        minIndex=i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(arr)):<span class="comment"># 寻找每次的最小值</span></span><br><span class="line">            minIndex=j <span class="keyword">if</span> arr[j]&lt;arr[minIndex] <span class="keyword">else</span> minIndex</span><br><span class="line">        arr[i],arr[minIndex]=arr[minIndex],arr[i]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度、空间复杂度分析</strong></p>
<p>最好情况（有序）:$O(n^2)$</p>
<p>比较$\frac{n(n-1)}2$、移动0，</p>
<p>最坏情况（逆序）:$O(n^2)$</p>
<p>比较$\frac{n(n-1)}2$、移动n-1；</p>
<p>平均情况:$O(n^2)$</p>
<p>比较$O(n^2)$、移动$O(n)$</p>
<h3 id="2-冒泡排序——时间复杂度：-O-N-2-、空间复杂度：-O-1"><a href="#2-冒泡排序——时间复杂度：-O-N-2-、空间复杂度：-O-1" class="headerlink" title="2.冒泡排序——时间复杂度：$O(N^2)$、空间复杂度：$O(1)$"></a>2.冒泡排序——时间复杂度：$O(N^2)$、空间复杂度：$O(1)$</h3><blockquote>
<p>左边大于右边交换一趟排下来最大的在右边，一次排序将最大的排在最右边，进行n-1个排序就排好了</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210509190446264.gif" alt="在这里插入图片描述"></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-<span class="number">1</span>): <span class="comment">#进行n-1轮，每轮排好一个数</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-<span class="number">1</span>-i): <span class="comment">#进行每轮的排序，找到最大的数排在最后</span></span><br><span class="line">            <span class="keyword">if</span> arr[j]&gt;arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j],arr[j+<span class="number">1</span>]=arr[j+<span class="number">1</span>],arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h4 id="冒泡排序的优化"><a href="#冒泡排序的优化" class="headerlink" title="冒泡排序的优化"></a>冒泡排序的优化</h4><blockquote>
<p>可以利用逆序对进行优化比较</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myBubleSort4</span><span class="params">(<span class="type">int</span> * nums, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">bool</span> isSwapped;</span><br><span class="line">	<span class="type">int</span> lastSwap = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> k = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">		isSwapped = <span class="literal">false</span>;  <span class="comment">//判断还有不有逆序对，没有了就true</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				nums[j] = nums[j] ^ nums[j + <span class="number">1</span>]; <span class="comment">//异或运算进行交换</span></span><br><span class="line">				nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>] ^ nums[j];</span><br><span class="line">				nums[j] = nums[j] ^ nums[j + <span class="number">1</span>];</span><br><span class="line">				isSwapped = <span class="literal">true</span>;</span><br><span class="line">				<span class="comment">//lastSwap之后的数都是排好序的</span></span><br><span class="line">				lastSwap = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!isSwapped) <span class="keyword">break</span>; <span class="comment">//没逆序对了，就停止</span></span><br><span class="line">		k = lastSwap;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="冒泡排序的应用"><a href="#冒泡排序的应用" class="headerlink" title="冒泡排序的应用"></a>冒泡排序的应用</h4><p><strong>最多交换k次冒泡排序</strong></p>
<p>冒泡排序通过交换相邻元素来调整元素的顺序</p>
<h3 id="3-插入排序——时间复杂度：-O-N-2-、空间复杂度：-O-1"><a href="#3-插入排序——时间复杂度：-O-N-2-、空间复杂度：-O-1" class="headerlink" title="3.插入排序——时间复杂度：$O(N^2)$、空间复杂度：$O(1)$"></a>3.插入排序——时间复杂度：$O(N^2)$、空间复杂度：$O(1)$</h3><blockquote>
<p>相当于抽牌，每取一个数，就与前面数做对比，如果小就往前走，找到小于或等于，插入即可</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210223174254141.gif" alt="在这里插入图片描述"></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j-<span class="number">1</span>]&gt;arr[j]:</span><br><span class="line">                arr[j],arr[j-<span class="number">1</span>]=arr[j-<span class="number">1</span>],arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h4 id="插入排序的改进：折半插入排序、希尔排序"><a href="#插入排序的改进：折半插入排序、希尔排序" class="headerlink" title="插入排序的改进：折半插入排序、希尔排序"></a>插入排序的改进：折半插入排序、希尔排序</h4><p>折半插入排序是采用折半查找的方法，可以更快地寻找插入位置，减少关键码的比较次数。但是他并不能减少排序元素的移动次数。比较次数为$O(NlogN)$、移动次数为$O(logN^2)$</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><blockquote>
<p>1.先选定一个小于N的整数gap作为第一增量，然后将所有距离为gap的元素分在同一组，并对每一组的元素进行直接插入排序。然后再取一个比第一增量小的整数作为第二增量，重复上述操作…<br>2.当增量的大小减到1时，就相当于整个序列被分到一组，进行一次直接插入排序，排序完成。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210509190237603.gif" alt="在这里插入图片描述"></p>
</blockquote>
<p><strong>代码如下</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//希尔排序</span><br><span class="line">void ShellSort(int* arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">	int gap = n;</span><br><span class="line">	while (gap&gt;1)</span><br><span class="line">	&#123;</span><br><span class="line">		//每次对gap折半操作</span><br><span class="line">		gap = gap / 2;</span><br><span class="line">		//单趟排序</span><br><span class="line">		for (int i = 0; i &lt; n - gap; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			int end = i;</span><br><span class="line">			int tem = arr[end + gap];</span><br><span class="line">			while (end &gt;= 0)</span><br><span class="line">			&#123;</span><br><span class="line">				if (tem &lt; arr[end])</span><br><span class="line">				&#123;</span><br><span class="line">					arr[end + gap] = arr[end];</span><br><span class="line">					end -= gap;</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			arr[end + gap] = tem;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-归并排序——时间复杂度：-O-NlogN-、空间复杂度：-O-N"><a href="#4-归并排序——时间复杂度：-O-NlogN-、空间复杂度：-O-N" class="headerlink" title="4.归并排序——时间复杂度：$O(NlogN)$、空间复杂度：$O(N)$"></a>4.归并排序——时间复杂度：$O(NlogN)$、空间复杂度：$O(N)$</h3><p><strong>前提知识：分治思想（递归）</strong></p>
<p><strong>分治思想</strong></p>
<blockquote>
<p><strong>分解步骤</strong>将问题划分为一些子问题，子问题的形式和原问题一样，只是规模更小。</p>
<p><strong>解决步骤</strong>递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。</p>
<p><strong>合并步骤</strong>将子问题的解组合成原问题的解。</p>
</blockquote>
<img src="/MyBlog/.io//image-20231005140333751.png" alt="image-20231005140333751" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetMax</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//arr[L..R]范围上求最大值 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[]arr,<span class="type">int</span> L,<span class="type">int</span> R)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L==R)&#123;<span class="comment">//arr[L..R]范围上只有一个数，直接返回，base case</span></span><br><span class="line">            <span class="keyword">return</span> arr[L];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=L+((R-L)&gt;&gt;<span class="number">1</span>);<span class="comment">//中点 </span></span><br><span class="line">        <span class="type">int</span> leftMax=process(arr,L,mid);</span><br><span class="line">        <span class="type">int</span> rightMax=process(arr,mid+<span class="number">1</span>,R);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMax,rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>中点有三种求法：</p>
<p>1.mid&#x3D;$\frac{L+R}{2}$ <strong>这种求法可能导致L+R溢出int范围，可能算出负的下标</strong></p>
<p>2.mid&#x3D;$L+\frac{R-L}{2}$<strong>这种求法不会溢出,补充：$\frac{L}{2}+\frac{R}{2}$如果出现奇数有问题</strong></p>
<p>3.mid&#x3D;$L+(R-L)&gt;&gt;1$<strong>这种求法是2的简化,(R-L)右移一位相当于除2</strong></p>
</blockquote>
<h4 id="Master-公式-一个递归，母问题规模为N，子问题规模都为N-b-："><a href="#Master-公式-一个递归，母问题规模为N，子问题规模都为N-b-：" class="headerlink" title="&#x3D;&#x3D;Master 公式(一个递归，母问题规模为N，子问题规模都为N&#x2F;b)：&#x3D;&#x3D;"></a>&#x3D;&#x3D;<font size="5"><strong>Master 公式(一个递归，母问题规模为N，子问题规模都为N&#x2F;b)：</strong></font>&#x3D;&#x3D;</h4><p>&#x3D;&#x3D;<strong>$T(N)&#x3D;a*T(\frac{N}b)+O(N^d)$</strong>&#x3D;&#x3D;<br>$$<br>\begin{cases}<br>O(N^d)&amp;log_ba&lt;d\<br>\<br>O(N^{log_ba})&amp;log_ba&gt;d\<br>\<br>O(N^d*logN)&amp;log_ba&#x3D;d<br>\end{cases}<br>$$<br><strong>归并排序：</strong></p>
<blockquote>
<p> 归并排序的基本思想（分治思想）：</p>
<p>1、（拆分）将一段数组分为左序列和右序列，让他们两个分别有序，再将左序列细分为左序列和右序列，如此重复该步骤，直到细分到区间不存在或者只有一个数字为止</p>
<p>2、（合并）将第一步得到的数字合并成有序区间</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/1a63567f7ebb40479e25919faf3cf131.gif" alt="img"></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个合并函数，用于将两个有序的子数组合并为一个有序的数组</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">arr, left, mid, right</span>):</span><br><span class="line">    <span class="comment"># 创建一个辅助数组</span></span><br><span class="line">    temp = []</span><br><span class="line">    <span class="comment"># 初始化两个指针，分别指向两个子数组的起始位置</span></span><br><span class="line">    i = left</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 比较两个子数组的元素，并将较小的元素放入辅助数组中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt;= arr[j]:</span><br><span class="line">            temp.append(arr[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp.append(arr[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将剩余的元素放入辅助数组中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        temp.append(arr[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= right:</span><br><span class="line">        temp.append(arr[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将辅助数组中的元素复制回原数组中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">        arr[i] = temp[i - left]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个归并排序函数，用于递归地对数组进行分解和合并</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr, left, right</span>):</span><br><span class="line">    <span class="comment"># 如果左边界小于右边界，说明还可以继续分解</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 计算中间位置</span></span><br><span class="line">        mid = left+((right-left)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 对左半部分进行归并排序</span></span><br><span class="line">        merge_sort(arr, left, mid)</span><br><span class="line">        <span class="comment"># 对右半部分进行归并排序</span></span><br><span class="line">        merge_sort(arr, mid + <span class="number">1</span>, right)</span><br><span class="line">        <span class="comment"># 将两个有序的子数组合并为一个有序的数组</span></span><br><span class="line">        merge(arr, left, mid, right)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr==<span class="literal">null</span> || arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>L+((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    process(arr,L,mid);</span><br><span class="line">    process(arr,mid+<span class="number">1</span>,R);</span><br><span class="line">    merge(arr,L,mid,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> M, <span class="type">int</span> R)</span>&#123;</span><br><span class="line">	<span class="type">int</span>[] help =<span class="keyword">new</span> <span class="title class_">int</span>[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p1=L;</span><br><span class="line">    <span class="type">int</span> p2=M+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1&lt;=M &amp;&amp; p2&lt;=R)&#123;</span><br><span class="line">        help[i++]=arr[p1]&lt;=arr[p2]?arr[p1++]:arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1&lt;=M)&#123;</span><br><span class="line">        help[i++]=arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2&lt;=R)&#123;</span><br><span class="line">        help[i++]=arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;help.length;i++)&#123;</span><br><span class="line">        arr[L+i]=help[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序的扩展"><a href="#归并排序的扩展" class="headerlink" title="归并排序的扩展"></a>归并排序的扩展</h4><h5 id="1-小和问题"><a href="#1-小和问题" class="headerlink" title="1.小和问题"></a>1.小和问题</h5><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。</p>
<p>eg:[1,3,4,2,5] 1左边比1小的数，没有；3左边比3小的数为1；4左边：1、3；2左边：1；5：1、3、4、2</p>
<p>所以小和为1+1+3+1+1+3+4+2&#x3D;16</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Small_Sum</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">small_sums</span>(<span class="params">self,li</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> li <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(li)&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.small_sum(li,<span class="number">0</span>,<span class="built_in">len</span>(li)-<span class="number">1</span>)</span><br><span class="line"><span class="comment">#进行递归的函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">small_sum</span>(<span class="params">self,li,l,r</span>):</span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = l + ((r-l) // <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># l = self.small_sum(li,l,mid)</span></span><br><span class="line">        <span class="comment"># r = self.small_sum(li,mid+1,r)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.small_sum(li,l,mid) + <span class="variable language_">self</span>.small_sum(li,mid+<span class="number">1</span>,r) + <span class="variable language_">self</span>.merge(li,l,mid,r)</span><br><span class="line"><span class="comment">#找出小和与排序</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self,li,l,mid,r</span>):</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="built_in">help</span> = []  <span class="comment">#定义临时列表来暂时存储元素</span></span><br><span class="line">        p1 = l <span class="comment">#两个指针</span></span><br><span class="line">        p2 = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt;= mid <span class="keyword">and</span> p2 &lt;= r:</span><br><span class="line">            res += (r - p2 + <span class="number">1</span>) * li[p1] <span class="keyword">if</span> li[p1] &lt; li[p2] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> li[p1] &lt; li[p2]:</span><br><span class="line">                <span class="built_in">help</span>.append(li[p1])</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">help</span>.append(li[p2])</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line"><span class="comment">#两个循环只能进去一个</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt;=mid:</span><br><span class="line">            <span class="built_in">help</span>.append(li[p1])</span><br><span class="line">            p1 +=<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> p2 &lt;= r:</span><br><span class="line">            <span class="built_in">help</span>.append(li[p2])</span><br><span class="line">            p2 +=<span class="number">1</span></span><br><span class="line">        li[l:r+<span class="number">1</span>] = <span class="built_in">help</span></span><br><span class="line">        <span class="keyword">return</span> res  <span class="comment">#返回小和</span></span><br><span class="line"> <span class="comment">#测试样例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    li = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">    ss = Small_Sum()</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">sum</span> = ss.small_sums(li)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>



<h5 id="2-逆序对问题"><a href="#2-逆序对问题" class="headerlink" title="2.逆序对问题"></a>2.逆序对问题</h5><p>在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inversion</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr)&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    merge_sort(arr,<span class="number">0</span>,<span class="built_in">len</span>(arr)-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">arr, left, mid, right</span>):</span><br><span class="line">    <span class="comment"># 创建一个辅助数组</span></span><br><span class="line">    temp = []</span><br><span class="line">    <span class="comment"># 初始化两个指针，分别指向两个子数组的起始位置</span></span><br><span class="line">    i = left</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 比较两个子数组的元素，并将较小的元素放入辅助数组中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt;= arr[j]:</span><br><span class="line">            temp.append(arr[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#当左边一个大时，说明从左边那个开始右边的都大，都是逆序对</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i,mid+<span class="number">1</span>): <span class="comment">#由于sort 会导致比较的那一个会merge到temp中，所以必须用for来打印</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;&lt;<span class="subst">&#123;arr[k]&#125;</span>,<span class="subst">&#123;arr[j]&#125;</span>&gt;&quot;</span>)</span><br><span class="line">            temp.append(arr[j])</span><br><span class="line">            j += <span class="number">1</span>        </span><br><span class="line">    <span class="comment"># 将剩余的元素放入辅助数组中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">        temp.append(arr[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= right:</span><br><span class="line">        temp.append(arr[j])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将辅助数组中的元素复制回原数组中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">        arr[i] = temp[i - left]</span><br><span class="line"><span class="comment"># 定义一个归并排序函数，用于递归地对数组进行分解和合并</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr, left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left== right:</span><br><span class="line">        <span class="keyword">return</span>    </span><br><span class="line">    <span class="comment"># 计算中间位置</span></span><br><span class="line">    mid = left+((right-left)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">    merge_sort(arr, left, mid)</span><br><span class="line">    merge_sort(arr, mid + <span class="number">1</span>, right)</span><br><span class="line">    merge(arr, left, mid, right)</span><br></pre></td></tr></table></figure>

<h3 id="5-快速排序——时间复杂度：优化后-O-NlogN-，未优化-O-N-2-、空间复杂度：最好（相当于二叉树）-O-logN-最差-O-N"><a href="#5-快速排序——时间复杂度：优化后-O-NlogN-，未优化-O-N-2-、空间复杂度：最好（相当于二叉树）-O-logN-最差-O-N" class="headerlink" title="5.快速排序——时间复杂度：优化后$O(NlogN)$，未优化$O(N^2)$、空间复杂度：最好（相当于二叉树）$O(logN)$最差$O(N)$"></a>5.快速排序——时间复杂度：优化后$O(NlogN)$，未优化$O(N^2)$、空间复杂度：最好（相当于二叉树）$O(logN)$最差$O(N)$</h3><p><font size="4"><strong>引入：荷兰国旗问题</strong></font></p>
<p><strong>问题一</strong></p>
<p>给定一个数组arr,和一个数num,请把小于等于num的数放在数组的左边,大于num的数放在数组的右边。要求额外空间复杂度O(1),时间复杂度O(N)</p>
<p><strong>问题二（荷兰国旗问题）</strong></p>
<p>给定一个数组arr,和一个数num,请把小于等于num的数放在数组的左边,等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1),时间复杂度O(N)</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231005195027117.png" alt="image-20231005195027117"></p>
<blockquote>
<p>解法：就如图</p>
<p>（1）当指针i的数小于等于num时，让这个指针的数和小于等于区的下个数作交换，小于等于区外扩，并且指针下移</p>
<p>（2）当指针i的数大于num时，下移</p>
<p>这样就能解决第一问</p>
</blockquote>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231005195433245.png" alt="image-20231005195433245"></p>
<h4 id="（1）前后指针法-最推荐用这种写法"><a href="#（1）前后指针法-最推荐用这种写法" class="headerlink" title="（1）前后指针法(最推荐用这种写法)"></a>（1）前后指针法(最推荐用这种写法)</h4><blockquote>
<p><strong>基本思想：</strong></p>
<p>我们定义两个指针cur和prev，选取key值,cur去遍历小于key的值,对prev++,交换cur与prev值,直至cur遍历完整个数组，prev位置的值一定是比key值小的，即key应处的正确位置，&#x3D;&#x3D;当将key放置在对应位置，则两端将分为大于key，和小于等于key的，则只需要将剩下的两部分继续进行上述步骤即递归即可，相当于每次确定一个数的位置&#x3D;&#x3D;</p>
<p><strong>动图展示：</strong><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/740448522c8d41979c87805fb635f7dc.gif" alt="img"></p>
<p>&#x3D;&#x3D;这个也可变为小于等于大于版本&#x3D;&#x3D;</p>
<img src="/MyBlog/.io//image-20231005200616749.png" alt="image-20231005200616749" style="zoom:50%;">
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> key = begin,pre = begin,cur = begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[cur] &lt; a[key] &amp;&amp; cur != pre)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(&amp;a[cur],&amp;a[++pre]);</span><br><span class="line">        &#125;</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;a[key],&amp;a[pre]);</span><br><span class="line">    key = pre;</span><br><span class="line">    <span class="built_in">quickSort</span>(a,begin,key - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a,key + <span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">arr,L,R</span>):</span><br><span class="line">    <span class="keyword">if</span> L&gt;=R:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> L&lt;R:</span><br><span class="line">       p=partition(arr,L,R)</span><br><span class="line">       quickSort(arr,L,p-<span class="number">1</span>)</span><br><span class="line">       quickSort(arr,p+<span class="number">1</span>,R)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr,L,R</span>):</span><br><span class="line">    prev=L</span><br><span class="line">    cur=L+<span class="number">1</span></span><br><span class="line">    key=L <span class="comment"># 选择第一个数作为基准</span></span><br><span class="line">    <span class="keyword">while</span> cur&lt;=R:</span><br><span class="line">        <span class="keyword">while</span> arr[cur]&lt;arr[key] <span class="keyword">and</span> cur!=prev:</span><br><span class="line">            prev+=<span class="number">1</span></span><br><span class="line">            arr[prev],arr[cur]=arr[cur],arr[prev]</span><br><span class="line">        cur+=<span class="number">1</span></span><br><span class="line">    arr[key],arr[prev]=arr[prev],arr[key]</span><br><span class="line">    <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>







<h4 id="2-hoare版本快排——学校用的这个版本"><a href="#2-hoare版本快排——学校用的这个版本" class="headerlink" title="(2)hoare版本快排——学校用的这个版本"></a>(2)hoare版本快排——学校用的这个版本</h4><blockquote>
<p>基本思想：</p>
<p>我们将左边值设为key,然后右边right先走,找小的,比key小停下来,然后左边left走找比key大,然后交换左边右边，继续上述过程，直至left和right相遇，此时的值一定是比key小的值，我们再把key和这个相遇位置的值进行交换，此时key所在的位置，左边的数据一定比key值小，右边的数据一定比key值大，即key放到了合适的位置上。重复此过程进行递归，直至所有的元素都处在合适位置。</p>
<p>动图展示：<img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/cde3ba9c95804870af9d4b1553e6b97b.gif" alt="img"></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/89bd712e32e9439883554543c52e9cea.gif" alt="img"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin &gt;= end) <span class="keyword">return</span>;<span class="comment">//当begin&gt;=end，结束递归操作</span></span><br><span class="line">    <span class="type">int</span> L = begin,R = end,key = begin;<span class="comment">//定义L,R,key下标</span></span><br><span class="line">    <span class="keyword">while</span>(L &lt; R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[R] &gt;= a[key] &amp;&amp; L &lt; R)<span class="comment">//右边先走，右边大于等于key就一直走下去，否则停下来，加上判断L &lt; R，防止越界</span></span><br><span class="line">        &#123;</span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(a[L] &lt;= a[key] &amp;&amp; L &lt; R)<span class="comment">//同理</span></span><br><span class="line">        &#123;</span><br><span class="line">            L++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(&amp;a[L],&amp;a[R]);<span class="comment">//都停下来后交换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;a[key],&amp;a[R]);<span class="comment">//最后key值和相遇点交换</span></span><br><span class="line">    key = R;<span class="comment">//以相遇点作为分界点，递归操作</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a,begin,key - <span class="number">1</span>);<span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">quickSort</span>(a,key + <span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-挖坑法"><a href="#3-挖坑法" class="headerlink" title="(3)挖坑法"></a>(3)挖坑法</h4><blockquote>
<p>基本思想：</p>
<p>挖坑法对hoare的思想进行了优化。我们设定key数组左边第一个值为坑,右边right找小,找到比key小的值填到坑位，right就成为新的坑位，然后左边left找大,找到后填到坑位上,left此时更新为新的坑位,循环此过程，right接着找小，left找大，交换形成新的坑位，直至left和right相遇。最后把key放到坑里，即类似于hoare版本key应处于的位置。</p>
<p>动图展示：<br><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/6669861612704fefa3b98d952d92a98b.gif" alt="img"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> L = begin,R = end,key = a[begin];</span><br><span class="line">    <span class="type">int</span> hole = L;</span><br><span class="line">    <span class="keyword">while</span>(L &lt; R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[R] &gt;= key &amp;&amp; L &lt; R)</span><br><span class="line">        &#123;</span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[hole] = a[R];</span><br><span class="line">        hole = R;</span><br><span class="line">        <span class="keyword">while</span>(a[L] &lt;= key &amp;&amp; L &lt; R)</span><br><span class="line">        &#123;</span><br><span class="line">            L++; </span><br><span class="line">        &#125;</span><br><span class="line">        a[hole] = a[L];</span><br><span class="line">        hole = L;</span><br><span class="line">    &#125;</span><br><span class="line">    a[hole] = key;</span><br><span class="line">    key = hole;</span><br><span class="line">    <span class="built_in">quickSort</span>(a,begin,key - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(a,key + <span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="快速排序的优化"><a href="#快速排序的优化" class="headerlink" title="快速排序的优化"></a>快速排序的优化</h4><h5 id="1-三数取中法、随机选key法—-随机与三数取中性能比较！"><a href="#1-三数取中法、随机选key法—-随机与三数取中性能比较！" class="headerlink" title="1.三数取中法、随机选key法— 随机与三数取中性能比较！"></a>1.三数取中法、随机选key法— 随机与三数取中性能比较！</h5><blockquote>
<p>&#x3D;&#x3D;快速排序对于数据是敏感的&#x3D;&#x3D;，如果这个序列是非常&#x3D;&#x3D;无序&#x3D;&#x3D;，杂乱无章的，那么快速排序的效率是非常高的，可是如果数列&#x3D;&#x3D;有序&#x3D;&#x3D;，时间复杂度就会从O(N*logN)变为O(N^2)，相当于冒泡排序了</p>
<p>若每趟排序所选的key都正好是该序列的中间值，即单趟排序结束后key位于序列正中间，那么快速排序的时间复杂度就是O(NlogN)</p>
<p>但是这是理想情况，当我们面对一组极端情况下的序列，就是有序的数组，选择左边作为key值的话，那么就会退化为O(N^2)的复杂度，所以此时我们选择首位置，尾位置，中间位置的数分别作为三数，选出中间位置的数，放到最左边，这样选key还是从左边开始，这样优化后，全部都变成了理想情况<br><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASGVybyAyMDIx,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
</blockquote>
<p><strong>随机选key法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">arr,L,R</span>):</span><br><span class="line">    <span class="keyword">if</span> L&gt;=R:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> L&lt;R:</span><br><span class="line">       key=random.randint(L,R)</span><br><span class="line">       arr[L],arr[key]=arr[key],arr[L] <span class="comment">#选择随机数作为基准将第一个数与随机数交换</span></span><br><span class="line">       p=partition(arr,L,R)</span><br><span class="line">       quickSort(arr,L,p-<span class="number">1</span>)</span><br><span class="line">       quickSort(arr,p+<span class="number">1</span>,R)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr,L,R</span>):</span><br><span class="line">    prev=L</span><br><span class="line">    cur=L+<span class="number">1</span></span><br><span class="line">    key=L <span class="comment"># 选择随机数作为基准</span></span><br><span class="line">    <span class="keyword">while</span> cur&lt;=R:</span><br><span class="line">        <span class="keyword">while</span> arr[cur]&lt;arr[key] <span class="keyword">and</span> cur!=prev:</span><br><span class="line">            prev+=<span class="number">1</span></span><br><span class="line">            arr[prev],arr[cur]=arr[cur],arr[prev]</span><br><span class="line">        cur+=<span class="number">1</span></span><br><span class="line">    arr[key],arr[prev]=arr[prev],arr[key]</span><br><span class="line">    <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>

<p><strong>三数取中法</strong></p>
<blockquote>
<p><strong>基本思想：</strong></p>
<p>在待排序数组的左端、右端和中间选择三个元素，并将这三个元素进行排序，将中间值作为枢纽元(pivot)来进行分割。这样可以尽量避免在有序数组中选择极值作为枢纽，从而提高快速排序的效率</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">GetMidIndex</span>(<span class="params">arr,L,R</span>):</span><br><span class="line">    mid=L+(R-L)&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> arr[L]&lt;arr[R]:</span><br><span class="line">        <span class="keyword">if</span> arr[mid]&lt;arr[R]:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> arr[mid]&gt;arr[R]:</span><br><span class="line">            <span class="keyword">return</span> R</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> L</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> arr[mid]&gt;arr[L]:</span><br><span class="line">            <span class="keyword">return</span> L</span><br><span class="line">        <span class="keyword">elif</span> arr[mid]&lt;arr[R]:</span><br><span class="line">            <span class="keyword">return</span> R</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">arr,L,R</span>):</span><br><span class="line">    <span class="keyword">if</span> L&gt;=R:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> L&lt;R:</span><br><span class="line">       key=GetMidIndex(arr,L,R)</span><br><span class="line">       arr[key],arr[L]=arr[L],arr[key]</span><br><span class="line">       p=partition(arr,L,R)</span><br><span class="line">       quickSort(arr,L,p-<span class="number">1</span>)</span><br><span class="line">       quickSort(arr,p+<span class="number">1</span>,R)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr,L,R</span>):</span><br><span class="line">    prev=L</span><br><span class="line">    cur=L+<span class="number">1</span></span><br><span class="line">    key=L <span class="comment"># 选择随机数作为基准</span></span><br><span class="line">    <span class="keyword">while</span> cur&lt;=R:</span><br><span class="line">        <span class="keyword">while</span> arr[cur]&lt;arr[key] <span class="keyword">and</span> cur!=prev:</span><br><span class="line">            prev+=<span class="number">1</span></span><br><span class="line">            arr[prev],arr[cur]=arr[cur],arr[prev]</span><br><span class="line">        cur+=<span class="number">1</span></span><br><span class="line">    arr[key],arr[prev]=arr[prev],arr[key]</span><br><span class="line">    <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure>

<h3 id="6-堆排序——时间复杂度：-O-NlogN-、空间复杂度：-O-1"><a href="#6-堆排序——时间复杂度：-O-NlogN-、空间复杂度：-O-1" class="headerlink" title="6.堆排序——时间复杂度：$O(NlogN)$、空间复杂度：$O(1)$"></a>6.堆排序——时间复杂度：$O(NlogN)$、空间复杂度：$O(1)$</h3><h4 id="前提知识——堆（heap）（优先队列-priority-queue）"><a href="#前提知识——堆（heap）（优先队列-priority-queue）" class="headerlink" title="前提知识——堆（heap）（优先队列-priority queue）"></a>前提知识——堆（heap）（优先队列-priority queue）</h4><p>堆要满足两点：</p>
<blockquote>
<p><font color="orange">堆是一个完全二叉树</font>；</p>
<p>第一，堆结构必须是一个&#x3D;&#x3D;完全二叉树&#x3D;&#x3D;，完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列，自然堆也具有完全二叉树的所有性质。</p>
</blockquote>
<blockquote>
<p><font color="orange"><strong>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。（即必须未大根堆或小根堆）</strong></font></p>
<p>第二点，堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。实际上，我们还可以换一种说法，堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</p>
</blockquote>
<p><strong>每个结点的值都大于或等于其左右孩子结点的值</strong>，我们叫做“大根堆”（大顶堆）。</p>
<p><strong>每个结点的值都小于或等于其左右孩子结点的值</strong>，我们叫做“小根堆”（小顶堆）。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA55qG6Ieq6JC9,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<p>我们设树的根结点为0，给定一个下标i，可以很容易计算得到它的父节点、左孩子、右孩子的下标。<br>$$<br>(从0出发)i的\begin{cases}<br>父结点&amp;\frac {i-1}2\<br>左孩子&amp;2\times i+1\<br>右孩子&amp;2\times i+2<br>\end{cases}<br>$$</p>
<h4 id="维护堆的性质"><a href="#维护堆的性质" class="headerlink" title="维护堆的性质"></a>维护堆的性质</h4><blockquote>
<p>heapify 和 heapInsert 是&#x3D;&#x3D;维护堆&#x3D;&#x3D;性质的重要过程。两者的时间复杂度都为O(logN),其中heapify是向下调整，heapInsert是向上调整。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//某个数现在在index位置，往上调整</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (arr[index]&gt;arr[index-<span class="number">1</span>]/<span class="number">2</span>)&#123;</span><br><span class="line">		swap(arr,index,(index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">		index=(index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//某个数现在在index位置，往下调整</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> index,<span class="type">int</span> heapSize)</span>&#123;</span><br><span class="line">	<span class="type">int</span> left=index*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//左孩子的下标</span></span><br><span class="line">	<span class="keyword">while</span>(left&lt;heapSize)&#123;<span class="comment">//下方还有孩子的时候</span></span><br><span class="line">		<span class="comment">//两个孩子中，谁的值大，把下标给largest</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span>left+<span class="number">1</span>&lt;heapSize &amp;&amp;arr[left + <span class="number">1</span>]&gt;arr[left]?left+<span class="number">1</span>:left;</span><br><span class="line">		<span class="comment">//父和孩子之间，谁的值大，把下标给largest</span></span><br><span class="line">		largest=arr[largest]&gt;arr[index]?largest:index;</span><br><span class="line">		<span class="keyword">if</span>(largest==index)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(arr,largest,index);</span><br><span class="line">		index=largest;</span><br><span class="line">		left=index*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><blockquote>
<p>我们可以用heapify自底向上的方法建立大根堆，当然也可以用heapInsert自上而下的方法建立大根堆，&#x3D;&#x3D;但是使用heapify建立大根堆的方法更快（实际上只是第一步快一点）,时间复杂度相对更低&#x3D;&#x3D;，所以一般使用heapify来建立大根堆，时间复杂度可用错位相减法估计为O(N)</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231008171228843.png" alt="image-20231008171228843"></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BuildHeap</span>(<span class="params">arr</span>): </span><br><span class="line">    n=<span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            heapify(arr, n, i)</span><br></pre></td></tr></table></figure>





<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote>
<p>堆排序的基本思想是：</p>
<ol>
<li>将待排序序列构<strong>造成一个大顶堆</strong></li>
<li>此时，整个序列的<strong>最大值</strong>就是<strong>堆顶的根节点</strong>。</li>
<li>将其与<strong>末尾元素进行交换</strong>，此时末尾就为最大值。</li>
<li>然后将<strong>剩余n-1个元素重新构造成一个堆</strong>，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数，用于调整指定节点及其子树为最大堆</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">arr, n, i</span>):</span><br><span class="line">    <span class="comment"># 初始化最大值的索引为当前节点</span></span><br><span class="line">    largest = i</span><br><span class="line">    <span class="comment"># 计算左右子节点的索引</span></span><br><span class="line">    left = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">    <span class="comment"># 如果左子节点存在且大于当前最大值，更新最大值的索引</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> arr[left] &gt; arr[largest]:</span><br><span class="line">        largest = left</span><br><span class="line">    <span class="comment"># 如果右子节点存在且大于当前最大值，更新最大值的索引</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> arr[right] &gt; arr[largest]:</span><br><span class="line">        largest = right</span><br><span class="line">    <span class="comment"># 如果最大值的索引不是当前节点，交换它们的位置，并递归调整被交换的子树</span></span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数，用于实现堆排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 获取数组的长度</span></span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="comment"># 从最后一个非叶子节点开始，自下而上构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line">    <span class="comment"># 从最后一个元素开始，自右而左交换堆顶元素和堆尾元素，并调整剩余的元素为最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr==<span class="literal">null</span>||arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 建立大根堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;<span class="comment">// O(N)</span></span><br><span class="line">		heapInsert(arr,i);	<span class="comment">//O(logN)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> heapSize=arr.length;</span><br><span class="line">	swap(arr,<span class="number">0</span>,--heapSize);<span class="comment">//先减再做交换，因为数组长度-1才是有效下标</span></span><br><span class="line">	<span class="keyword">while</span>(heapSize&gt;<span class="number">0</span>)&#123;<span class="comment">//O(N)</span></span><br><span class="line">		heapif(arr,<span class="number">0</span>,heapSize);<span class="comment">//O(logN)</span></span><br><span class="line">		swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆排序扩展题目"><a href="#堆排序扩展题目" class="headerlink" title="堆排序扩展题目"></a>堆排序扩展题目</h4><p>已知一个几乎有序的数组，几乎有序是指，如果把数组排号顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数组进行排序。</p>
<blockquote>
<p>利用小根堆，每次在k元素内建立小根堆，弹出最小值，放在最前的位置，重复即可，时间复杂度为O(Nlogk)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortedArrDistanceLessK</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">	<span class="comment">//默认小根堆</span></span><br><span class="line">	PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">	<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;index&lt;=Math.min(arr.length,k);index++)&#123;</span><br><span class="line">		heap.add(arr[index]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;index&lt;arr.length;i++,index++)&#123;</span><br><span class="line">		heap.add(arr[index]);</span><br><span class="line">		arr[i]=heap.poll();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!heap.isEmpty())&#123;</span><br><span class="line">		arr[i++]=heap.poll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线性时间排序（不基于比较的排序）"><a href="#线性时间排序（不基于比较的排序）" class="headerlink" title="线性时间排序（不基于比较的排序）"></a>线性时间排序（不基于比较的排序）</h3><h3 id="7-桶排序——时间复杂度：最好-O-N-K-最坏-O-N-2-、空间复杂度-O-N-K"><a href="#7-桶排序——时间复杂度：最好-O-N-K-最坏-O-N-2-、空间复杂度-O-N-K" class="headerlink" title="7.桶排序——时间复杂度：最好$O(N+K)$ 最坏$O(N^2)$、空间复杂度$O(N+K)$"></a>7.桶排序——时间复杂度：最好$O(N+K)$ 最坏$O(N^2)$、空间复杂度$O(N+K)$</h3><blockquote>
<p><strong>1、算法原理：</strong></p>
<p>桶排序的核心思想就是&#x3D;&#x3D;将要排序的数据分到几个有序的桶里&#x3D;&#x3D;，每个桶里的数据再单独进行排序。桶排序完之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<p><strong>2、图片演示：</strong></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20200622162250898.gif" alt="在这里插入图片描述"></p>
<p>3、<strong>算法分析</strong>：</p>
<p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k&#x3D;n&#x2F;m 个元素。每个桶内部使用归并排序，时间复杂度为 O(k * logk)。&#x3D;&#x3D;m 个桶排序的时间复杂度就是 O(m * k * logk)&#x3D;&#x3D;，因为 k&#x3D;n&#x2F;m，所以整个桶排序的时间复杂度就是 O(n*log(n&#x2F;m))。当桶的个数m 接近数据个数 n 时，log(n&#x2F;m) 就是一个非常小的常量，这个时候桶排序的时间复杂度&#x3D;&#x3D;接近 O(n)&#x3D;&#x3D;。</p>
<p>所以，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少，但相应的空间消耗就会增大。 </p>
<p>4、<strong>桶排序的使用条件和适用场景</strong>：</p>
<p>桶排序对要排序的数据的要求是非常苛刻的。使用条件如下：</p>
<p>（1）首先，要排序的数据需要很容易就能划分成m个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内数据都排序完之后，桶与桶之间的数据不需要在进行排序。</p>
<p>（2）其次，数据在各个桶之间的分布比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</p>
<p>所以，桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<p>5、<strong>应用案例</strong>：</p>
<p>（1）需求描述：有10GB的订单数据，需按订单金额（假设金额都是正整数）进行排序，但内存有限，仅几百MB。</p>
<p>（2）解决思路：</p>
<blockquote>
<p>扫描一遍文件，看订单金额所处数据范围，比如1元-10万元，那么就分100个桶。</p>
<p>第一个桶存储金额1-1000元之内的订单，第二个桶存1001-2000元之内的订单，依次类推。</p>
<p>每个桶对应一个文件，并按照金额范围的大小顺序编号命名（00，01，02，…，99）。</p>
<p>将100个小文件依次放入内存并用快排排序。</p>
<p>所有文件排好序后，只需按照文件编号从小到大依次读取每个小文件并写到大文件中即可。</p>
<p>注意点：若单个文件无法全部载入内存，则针对该文件继续按照前面的思路进行处理即可。</p>
</blockquote>
</blockquote>
<h3 id="8-计数排序——时间复杂度-O-N-K-、空间复杂度-O-N-K"><a href="#8-计数排序——时间复杂度-O-N-K-、空间复杂度-O-N-K" class="headerlink" title="8.计数排序——时间复杂度$O(N+K)$、空间复杂度$O(N+K)$"></a>8.计数排序——时间复杂度$O(N+K)$、空间复杂度$O(N+K)$</h3><blockquote>
<p>1、<strong>算法原理</strong>：</p>
<p>&#x3D;&#x3D;计数排序可以看成是桶排序的一种特殊情况&#x3D;&#x3D;，只是桶的大小粒度不一样。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>
<p>2、<strong>适用场景</strong>：</p>
<p>&#x3D;&#x3D;计数排序只能用在数据范围不大的场景中&#x3D;&#x3D;，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<p>3、<strong>动图演示</strong>：</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20181219185934399" alt="img"></p>
<p>4、<strong>算法分析</strong>：</p>
<p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个计数排序函数，参数为一个整数向量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counting_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出向量中的最大值和最小值</span></span><br><span class="line">    <span class="type">int</span> max_num = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> min_num = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        max_num = <span class="built_in">max</span>(max_num, num);</span><br><span class="line">        min_num = <span class="built_in">min</span>(min_num, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个计数向量，大小为最大值和最小值的差加一</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(max_num - min_num + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 遍历原向量，对每个元素在计数向量中对应的位置加一</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        count[num - min_num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历计数向量，将每个元素按照出现的次数依次放回原向量</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums[index++] = i + min_num;</span><br><span class="line">            count[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; <span class="comment">// 输入的整数个数</span></span><br><span class="line">    cin &gt;&gt; n; <span class="comment">// 输入整数个数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>; <span class="comment">// 创建一个存储整数的向量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; nums[i]; <span class="comment">// 输入每个整数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">counting_sort</span>(nums); <span class="comment">// 对整数进行计数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出排序后的整数</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-基数排序——时间复杂度-O-N-times-K-、空间复杂度-O-N-K"><a href="#9-基数排序——时间复杂度-O-N-times-K-、空间复杂度-O-N-K" class="headerlink" title="9.基数排序——时间复杂度$O(N\times K)$、空间复杂度$O(N+K)$"></a>9.基数排序——时间复杂度$O(N\times K)$、空间复杂度$O(N+K)$</h3><blockquote>
<p>1、<strong>算法原理</strong>：</p>
<p>&#x3D;&#x3D;基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集&#x3D;&#x3D;；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p>2、<strong>使用条件</strong>：</p>
<p>&#x3D;&#x3D;基数排序对要排序的数据是有要求的&#x3D;&#x3D;，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，因为&#x3D;&#x3D;基数要借助桶排序或者计数排序算法&#x3D;&#x3D;来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p>
<p>3、<strong>动图演示</strong>：</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20181219185934456" alt="img"></p>
<p>4、<strong>算法分析</strong>：</p>
<p>（1）基数排序基于分别排序，分别收集，所以是稳定的。</p>
<p>（2）如果要排序的数据有 k 位，那我们就&#x3D;&#x3D;需要 k 次桶排序或者计数排序&#x3D;&#x3D;，总的时间复杂度是 &#x3D;&#x3D;O(k*n)&#x3D;&#x3D;。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。</p>
<p>（3）基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个基数排序函数，参数为一个整数向量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radix_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出向量中的最大值</span></span><br><span class="line">    <span class="type">int</span> max_num = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        max_num = <span class="built_in">max</span>(max_num, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大值的位数</span></span><br><span class="line">    <span class="type">int</span> digits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        digits++;</span><br><span class="line">        max_num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个存储0-9的队列数组</span></span><br><span class="line">    vector&lt;queue&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 从低位到高位进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; digits; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历原向量，将每个元素按照当前位的数字放入对应的队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> digit = (num / (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>, i)) % <span class="number">10</span>; <span class="comment">// 计算当前位的数字</span></span><br><span class="line">            buckets[digit].<span class="built_in">push</span>(num); <span class="comment">// 将元素放入队列中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历队列数组，将每个队列中的元素依次放回原向量</span></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!buckets[j].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                nums[index++] = buckets[j].<span class="built_in">front</span>(); <span class="comment">// 取出队列首元素放入原向量</span></span><br><span class="line">                buckets[j].<span class="built_in">pop</span>(); <span class="comment">// 弹出队列首元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; <span class="comment">// 输入的整数个数</span></span><br><span class="line">    cin &gt;&gt; n; <span class="comment">// 输入整数个数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>; <span class="comment">// 创建一个存储整数的向量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; nums[i]; <span class="comment">// 输入每个整数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">radix_sort</span>(nums); <span class="comment">// 对整数进行基数排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出排序后的整数</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h3><p><strong>常见数据结构排序算法的时间复杂度、空间复杂度、稳定性</strong></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/7f0a072a02f34c3fbae49708575f365d.webp" alt="img"></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231016084233401.png" alt="image-20231016084233401"></p>
<h3 id="比较器的使用"><a href="#比较器的使用" class="headerlink" title="比较器的使用"></a>比较器的使用</h3><p><strong>1）比较器的实质就是重载比较运算符</strong></p>
<p><strong>2）比较器可以很好的应用在特殊标准的排序上</strong></p>
<p><strong>3）比较器可以很好的应用在根据特殊标准排序的结构上</strong></p>
<p><strong>形式</strong></p>
<p>C++:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span> <span class="comment">//需要用algorithm库</span></span></span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),compare);</span><br></pre></td></tr></table></figure>

<p>Java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comparator</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">		Arrays.sort(arr);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>类型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体，存储学生的学号，语文成绩和数学成绩</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id; <span class="comment">// 学号</span></span><br><span class="line">    <span class="type">int</span> chinese; <span class="comment">// 语文成绩</span></span><br><span class="line">    <span class="type">int</span> math; <span class="comment">// 数学成绩</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个比较函数，用于排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(Student a, Student b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果语文成绩不同，按语文成绩降序排序</span></span><br><span class="line">    <span class="keyword">if</span> (a.chinese != b.chinese) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.chinese &gt; b.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果语文成绩相同，但数学成绩不同，按数学成绩降序排序</span></span><br><span class="line">    <span class="keyword">if</span> (a.math != b.math) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.math &gt; b.math;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果语文成绩和数学成绩都相同，按学号升序排序</span></span><br><span class="line">    <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; <span class="comment">// 学生数量</span></span><br><span class="line">    cin &gt;&gt; n; <span class="comment">// 输入学生数量</span></span><br><span class="line">    <span class="function">vector&lt;Student&gt; <span class="title">students</span><span class="params">(n)</span></span>; <span class="comment">// 创建一个存储学生的向量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; students[i].id &gt;&gt; students[i].chinese &gt;&gt; students[i].math; <span class="comment">// 输入每个学生的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), compare); <span class="comment">// 对学生进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; students[i].id &lt;&lt; endl; <span class="comment">// 输出每个学生的学号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、链表"><a href="#三、链表" class="headerlink" title="三、链表"></a>三、链表</h2><h3 id="1-哈希表-散列表-的简单介绍"><a href="#1-哈希表-散列表-的简单介绍" class="headerlink" title="1.哈希表(散列表)的简单介绍"></a>1.哈希表(散列表)的简单介绍</h3><blockquote>
<p>1）哈希表在使用层面上可以理解为一种集合结构</p>
<p>2）如果只有key，没有伴随数据value，可以使用HashSet结构（C++中叫UnOrderedSet）</p>
<p>3）如果既有key，又有伴随数据value，可以使用HashMap结构（C++中叫UnOrderedMap）</p>
<p>4）有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事</p>
<p>5）使用哈希表增（put）、删（remove）、查（get）、改（put）的操作，可以认为时间复杂度为&#x3D;&#x3D;O（1）&#x3D;&#x3D;，但是常数时间比较大</p>
<p>6）放入哈希表的东西，如果是基础类型，内部按&#x3D;&#x3D;值&#x3D;&#x3D;传递，内存占用就是这个东西的大小（<strong>相当于深拷贝，把值给拷贝了</strong>）</p>
<p>7）放入哈希表的东西，如果不是基础类型，内部按&#x3D;&#x3D;引用&#x3D;&#x3D;传递，内存占用时这个东西内存地址的大小(<strong>相当于浅拷贝，引用</strong>)</p>
</blockquote>
<h3 id="2-有序表的简单介绍"><a href="#2-有序表的简单介绍" class="headerlink" title="2.有序表的简单介绍"></a>2.有序表的简单介绍</h3><blockquote>
<p>1）有序表在使用层面上可以理解为一种集合结构</p>
<p>2）如果只有key，没有伴随数据value，可以使用TreeSet结构（C++中叫OrderedSet）</p>
<p>3）如果既有key，又有伴随数据value，可以使用TreeMap结构（C++中叫OrderedMap）</p>
<p>4）有无伴随数据，是HashMap和HashSet唯一的区别，底层的实际结构是一回事</p>
<p>5）红黑树、AVL数、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现不同</p>
<p>6）放入哈希表的东西，如果是基础类型，内部按&#x3D;&#x3D;值&#x3D;&#x3D;传递，内存占用就是这个东西的大小（<strong>相当于深拷贝，把值给拷贝了</strong>）</p>
<p>7）放入哈希表的东西，如果不是基础类型，内部按&#x3D;&#x3D;引用&#x3D;&#x3D;传递，内存占用时这个东西内存地址的大小(<strong>相当于浅拷贝，引用</strong>)</p>
<p>8）不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复杂度</p>
</blockquote>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231007172149804.png" alt="image-20231007172149804"></p>
<h3 id="3-链表"><a href="#3-链表" class="headerlink" title="3.链表"></a>3.链表</h3><blockquote>
<p><strong>一、链表定义</strong><br>链表是由一系列连接在一起的结点构成，其中的<strong>每个结点</strong>都是<strong>一个数据结构</strong>。<br>链表的结点通常是动态分配、使用和删除的，允许链表在程序运行时增大或缩小。如果需要将新信息添加到链表中，则程序只需分配另一个结点并将其插入到系列中。如果需要从链表中删除特定的信息块，则程序将删除包含该信息的结点。</p>
<p><strong>二、链表的结构</strong></p>
<h5 id="2-1-单个节点的组成"><a href="#2-1-单个节点的组成" class="headerlink" title="2.1 单个节点的组成"></a>2.1 单个节点的组成</h5><p>链表的每个节点，除数据之外还包含一个后继指针指向链表中的下一个节点。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/2bf369f67b0148258cfcdcd6275493a1.png" alt="链表单个节点的组成"></p>
<p>三、链表的种类<br>在实际中，链表有许多形式，根据单向、双向；带头、不带头；循环、非循环的排列组合，就有八种形式的链表。<br>下面举几个常见的链表：</p>
<p>不带头单链表</p>
<img src="/MyBlog/.io//b39dd3b31b644f77ac1959a67ef4b63d.png" alt="在这里插入图片描述">

<p>不带头双向链表</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/1a42fd49712949c0b3c84d68badde38d.png" alt="在这里插入图片描述"></p>
<p>带头单链表</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/6fe23fca88a44015879f8209dde6826b.png" alt="在这里插入图片描述"></p>
<p>循环单链表</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/0daa877f7f09484394087ec7a26375bf.png" alt="在这里插入图片描述"></p>
<p>带头双向循环链表</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/3cfe70d45ee444aba9ac3bf3c550b8b3.png" alt="在这里插入图片描述"></p>
</blockquote>
<h4 id="单向链表的代码实现（C-）"><a href="#单向链表的代码实现（C-）" class="headerlink" title="单向链表的代码实现（C++）"></a>单向链表的代码实现（C++）</h4><h5 id="一、链表定义（struct）"><a href="#一、链表定义（struct）" class="headerlink" title="一、链表定义（struct）"></a>一、链表定义（struct）</h5><p>下面的结构体定义了C++语言中的一种常见的链表节点，包括数据、指针和两种不同类型的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;        <span class="comment">//存储数据</span></span><br><span class="line">    ListNode *next; <span class="comment">//next指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;  <span class="comment">//类似构造函数</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="二、节点创建"><a href="#二、节点创建" class="headerlink" title="二、节点创建"></a>二、节点创建</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *node1 = <span class="keyword">new</span> ListNode;</span><br><span class="line">    ListNode *node2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>();   <span class="comment">// 初始化值为0</span></span><br><span class="line"> 	ListNode *node3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">100</span>); <span class="comment">// 初始化值为100</span></span><br><span class="line"></span><br><span class="line"> 	cout&lt;&lt; node1-&gt;val&lt;&lt;endl;</span><br><span class="line"> 	cout&lt;&lt; node2-&gt;val&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; node3-&gt;val&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、插入节点"><a href="#三、插入节点" class="headerlink" title="三、插入节点"></a>三、插入节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	ListNode *node1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">100</span>); <span class="comment">// 初始化值为-1</span></span><br><span class="line"> 	ListNode *node2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">200</span>); <span class="comment">// 初始化值为-1</span></span><br><span class="line"></span><br><span class="line"> 	node1-&gt;next=node2;</span><br><span class="line"></span><br><span class="line"> 	cout&lt;&lt; node1-&gt;next-&gt;val&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、循环建立链表"><a href="#四、循环建立链表" class="headerlink" title="四、循环建立链表"></a>四、循环建立链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	ListNode *head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">//头节点</span></span><br><span class="line">    ListNode *p=head;                <span class="comment">//指针</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">5</span>)&#123;</span><br><span class="line">        ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i); <span class="comment">// 初始化一个节点</span></span><br><span class="line">        p-&gt;next = node;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//最后一个节点的指针指向空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、遍历链表"><a href="#五、遍历链表" class="headerlink" title="五、遍历链表"></a>五、遍历链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	ListNode *head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">//头节点</span></span><br><span class="line">    ListNode *p=head;                <span class="comment">//指针</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">5</span>)&#123;</span><br><span class="line">        ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i); <span class="comment">// 初始化一个节点</span></span><br><span class="line">        p-&gt;next = node;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//最后一个节点的指针指向空</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//遍历链表部分</span></span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;val;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="六、删除节点"><a href="#六、删除节点" class="headerlink" title="六、删除节点"></a>六、删除节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	ListNode *head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">//头节点</span></span><br><span class="line">    ListNode *p=head;                <span class="comment">//指针</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="number">5</span>)&#123;</span><br><span class="line">        ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i); <span class="comment">// 初始化一个节点</span></span><br><span class="line">        p-&gt;next = node;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//最后一个节点的指针指向空</span></span><br><span class="line">    p=head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第二个节点</span></span><br><span class="line">    ListNode *pre = p-&gt;next;</span><br><span class="line">    p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> pre;</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双向链表的实现"><a href="#双向链表的实现" class="headerlink" title="双向链表的实现"></a>双向链表的实现</h4><h5 id="一、链表定义（struct）-1"><a href="#一、链表定义（struct）-1" class="headerlink" title="一、链表定义（struct）"></a>一、链表定义（struct）</h5><p>下面的结构体定义了C++语言中的一种常见的链表节点，包括数据、指针和两种不同类型的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DoubleListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val; <span class="comment">//存储数据</span></span><br><span class="line">    DoubleListNode *next=<span class="literal">nullptr</span>; <span class="comment">//next指针指向下一结点</span></span><br><span class="line">    DoubleListNode *pre=<span class="literal">nullptr</span>;<span class="comment">//pre指针指向上一结点</span></span><br><span class="line">    <span class="built_in">DoubleListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>),<span class="built_in">pre</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">DoubleListNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">nullptr</span>),<span class="built_in">pre</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="二、节点创建-1"><a href="#二、节点创建-1" class="headerlink" title="二、节点创建"></a>二、节点创建</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DoubleListNode *node1=<span class="keyword">new</span> DoubleListNode;</span><br><span class="line">    DoubleListNode *node2=<span class="keyword">new</span> <span class="built_in">DoubleListNode</span>();</span><br><span class="line">    DoubleListNode *node3=<span class="keyword">new</span> <span class="built_in">DoubleListNode</span>(<span class="number">100</span>);</span><br><span class="line">    cout&lt;&lt;node1-&gt;val&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;node2-&gt;val&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;node3-&gt;val&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、插入节点-1"><a href="#三、插入节点-1" class="headerlink" title="三、插入节点"></a>三、插入节点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	DoubleListNode *node1 = <span class="keyword">new</span> <span class="built_in">DoubleListNode</span>(<span class="number">100</span>); <span class="comment">// 初始化值为-1</span></span><br><span class="line"> 	DoubleListNode *node2 = <span class="keyword">new</span> <span class="built_in">DoubleListNode</span>(<span class="number">200</span>); <span class="comment">// 初始化值为-1</span></span><br><span class="line"></span><br><span class="line"> 	node1-&gt;next=node2;</span><br><span class="line"></span><br><span class="line"> 	cout&lt;&lt; node1-&gt;next-&gt;val&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、循环建立链表-1"><a href="#四、循环建立链表-1" class="headerlink" title="四、循环建立链表"></a>四、循环建立链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	DoubleListNode *head=<span class="keyword">new</span> <span class="built_in">DoubleListNode</span>();</span><br><span class="line">    DoubleListNode *p=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        DoubleListNode *temp=<span class="keyword">new</span> <span class="built_in">DoubleListNode</span>(i);</span><br><span class="line">        p-&gt;next=temp;</span><br><span class="line">        temp-&gt;pre=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、遍历链表-1"><a href="#五、遍历链表-1" class="headerlink" title="五、遍历链表"></a>五、遍历链表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	DoubleListNode *head=<span class="keyword">new</span> <span class="built_in">DoubleListNode</span>();</span><br><span class="line">    DoubleListNode *p=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        DoubleListNode *temp=<span class="keyword">new</span> <span class="built_in">DoubleListNode</span>(i);</span><br><span class="line">        p-&gt;next=temp;</span><br><span class="line">        temp-&gt;pre=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="comment">//正向遍历</span></span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;val;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p=p-&gt;pre; 当p指针已经指向了链表的最后一个结点，这时p指针已经是一个空指针，那么这一句就没用</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    p=head;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反向遍历</span></span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;p-&gt;val;</span><br><span class="line">        p=p-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="六、删除节点-1"><a href="#六、删除节点-1" class="headerlink" title="六、删除节点"></a>六、删除节点</h5><p>略，与单向链表一样</p>
<h4 id="链表常见题"><a href="#链表常见题" class="headerlink" title="链表常见题"></a>链表常见题</h4><h4 id="一、反转单向和双向链表"><a href="#一、反转单向和双向链表" class="headerlink" title="一、反转单向和双向链表"></a>一、反转单向和双向链表</h4><h4 id="1、反转单向链表"><a href="#1、反转单向链表" class="headerlink" title="1、反转单向链表"></a>1、反转单向链表</h4><h5 id="1、迭代反转"><a href="#1、迭代反转" class="headerlink" title="1、迭代反转"></a>1、迭代反转</h5><blockquote>
<ul>
<li>定义一个指针 cur，用来遍历链表</li>
<li>定义一个指针 prev，保存 cur 的上一个节点的位置，初始指向 NULL</li>
<li>定义一个指针 next(temp)，保存 cur 的下一个节点的位置，用来迭代<img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210831161759.png" alt="image-20210831161758939"></li>
<li>通过 prev 和 cur 来调整每个节点指针的方向，next 进行迭代</li>
<li><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210831165901.png" alt="image-20210831165901352"></li>
</ul>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList1</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;  <span class="comment">// 定义 pre 指针，初始化为 nullptr；</span></span><br><span class="line">    ListNode* cur = head;  <span class="comment">// 定义 cur 指针，指向头结点；</span></span><br><span class="line">    <span class="comment">//迭代反转，利用三个指针，当cur从头结点移动到尾结点停止</span></span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        ListNode* tmp = cur-&gt;next;  <span class="comment">// 定义 temp 指针，指向 cur-&gt;next 节点</span></span><br><span class="line">        cur-&gt;next = pre;<span class="comment">//将头指向null</span></span><br><span class="line">        <span class="comment">// 后移 pre 和 cur 指针</span></span><br><span class="line">        pre = cur;  </span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015164339649.png" alt="image-20231015164339649"></p>
<h5 id="2、头插法"><a href="#2、头插法" class="headerlink" title="2、头插法"></a>2、头插法</h5><blockquote>
<p>把链表中的所有节点依次头插到一个新链表中，相当于反转了原链表</p>
<ul>
<li><p>定义一个指针 cur，用来遍历原链表</p>
</li>
<li><p>定义一个指针 next，保存 cur 的下一个节点的位置</p>
</li>
<li><p>定义一个指针 newhead，指向新链表的头节点</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210901234402.gif" alt="反转链表"></p>
</li>
</ul>
</blockquote>
<p><strong>代码如下</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头插法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList2</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* cur=head;</span><br><span class="line">    ListNode* newhead=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//next 保存当前cur所在结点的下一个结点的位置</span></span><br><span class="line">        ListNode* next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=newhead;<span class="comment">//开始头插</span></span><br><span class="line">        newhead=cur;<span class="comment">//更新头结点</span></span><br><span class="line">        cur=next;<span class="comment">//cur指向下一个待插入的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015164541012.png" alt="image-20231015164541012"></p>
<h5 id="3、就地逆转法"><a href="#3、就地逆转法" class="headerlink" title="3、就地逆转法"></a>3、就地逆转法</h5><blockquote>
<p><strong>一、若有头结点</strong></p>
<p>就地逆置法和头插法的实现思想类似，唯一的区别在于，头插法是通过建立一个新链表实现的，而就地逆置法则是直接对原链表做修改，从而实现将原链表反转</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/f6b9f4816a1d45049cd5b2d31708d67f.png" alt="img"></p>
<img src="/MyBlog/.io//a56d42cbfe9248d18e7031394fbf4950.png" alt="img" style="zoom:50%;">

<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/cec794ecf4314233bd2037d520fee8fa.png" alt="img"></p>
<p><strong>二、若无头结点</strong></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/0e412961c90f4767ad5b1f68490db24f.png" alt="img"></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/c9d54c3cdb93453bb988ab875f8ca9b3.png" alt="img"></p>
</blockquote>
<p><strong>代码如下</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 就地逆转法 有头结点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList3</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* pre=head-&gt;next;</span><br><span class="line">    ListNode* cur=head-&gt;next-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pre-&gt;next=cur-&gt;next;<span class="comment">//将cur从链表中摘除</span></span><br><span class="line">        cur-&gt;next=head-&gt;next;<span class="comment">//将cur移动至链表头，将cur的下一个指向pre</span></span><br><span class="line">        head-&gt;next=cur;<span class="comment">//将头指向cur</span></span><br><span class="line">        cur=pre-&gt;next;<span class="comment">//将cur调整至pre的下一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//就地逆转法 无头结点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList32</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* pre=head;</span><br><span class="line">    ListNode* cur=head-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pre-&gt;next=cur-&gt;next;<span class="comment">//将cur从链表中摘除</span></span><br><span class="line">        cur-&gt;next=head;<span class="comment">//将cur移动至链表头，将cur的下一个指向pre</span></span><br><span class="line">        head=cur;<span class="comment">//将头指向cur</span></span><br><span class="line">        cur=pre-&gt;next;<span class="comment">//将cur调整至pre的下一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015170435870.png" alt="image-20231015170435870"></p>
<h5 id="4、递归反转"><a href="#4、递归反转" class="headerlink" title="4、递归反转"></a>4、递归反转</h5><blockquote>
<p><strong>实现思想:</strong></p>
<p>从链表的尾结点开始，依次向前遍历，遍历过程依次改变各结点的指向，即令其指向前一个结点。这种方法一般会在函数中建立一个新的头指针，通过层层递进的方式找到链表尾结点，然后将新的头指针指向尾结点，再层层返回把每个遍历后的结点都指向上一个结点，最后令原先的头结点指向NULL，使其成为链表反转后，新链表的尾结点，并返回新的头指针。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/v2-f26f04e3c58f44ec4d0e98965669283d_1440w.webp" alt="img"></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/v2-6d13f5c9fbf9f2df6da862185be61d8b_1440w.webp" alt="img"></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/v2-16a415df23196b6a9d5f724b40e6e4c2_1440w.webp" alt="img"></p>
</blockquote>
<p><strong>代码如下</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归反转法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList4</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* newhead=<span class="built_in">reverseList4</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next=head;</span><br><span class="line">    head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015170528579.png" alt="image-20231015170528579"></p>
<h4 id="2、反转双向链表"><a href="#2、反转双向链表" class="headerlink" title="2、反转双向链表"></a>2、反转双向链表</h4><p>双向链表的反转与单向链表原理类似，只是双向链表多了一个指针，则需多一个指针记录前一结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DoubleListNode* <span class="title">reverseDoubleList1</span><span class="params">(DoubleListNode* head)</span></span>&#123;</span><br><span class="line">    DoubleListNode *cur=<span class="literal">NULL</span>;</span><br><span class="line">    DoubleListNode *prev=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">    &#123;</span><br><span class="line">        cur=head-&gt;next;<span class="comment">//记录下一个结点</span></span><br><span class="line">        <span class="comment">//将结点的两指针反向</span></span><br><span class="line">        head-&gt;next=prev;</span><br><span class="line">        head-&gt;pre=cur;</span><br><span class="line">        <span class="comment">//记录当前结点，方便指前一个结点</span></span><br><span class="line">        prev=head;</span><br><span class="line">        <span class="comment">//将head指针移动至下个结点</span></span><br><span class="line">        head=cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、打印两个有序链表的公共部分"><a href="#二、打印两个有序链表的公共部分" class="headerlink" title="二、打印两个有序链表的公共部分"></a>二、打印两个有序链表的公共部分</h4><p>给定两个有序链表的头指针head1和head2，打印两个链表的公共部分</p>
<blockquote>
<p>从头结点开始，不等时移动小的指针，相等时输出即可</p>
<img src="/MyBlog/.io//image-20231013093408460.png" alt="image-20231013093408460" style="zoom: 33%;">
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(p1!=<span class="literal">nullptr</span> &amp;&amp; p2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val==p2-&gt;val)&#123;</span><br><span class="line">            cout&lt;&lt;p1-&gt;val;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val&lt;p2-&gt;val)&#123;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val&gt;p2-&gt;val)&#123;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、判断一个链表是否为回文结构"><a href="#三、判断一个链表是否为回文结构" class="headerlink" title="三、判断一个链表是否为回文结构"></a>三、判断一个链表是否为回文结构</h4><p>给定一个单链表的头节点head，请判断该链表是否为回文结构。</p>
<p><strong>第一种解法：利用栈，容易写，像笔试建议写，空间复杂度O（N）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome1</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    stack&lt;ListNode*&gt; stk;</span><br><span class="line">    ListNode *cur=head;</span><br><span class="line">    <span class="comment">//将链表结点压栈</span></span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(cur);</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈与链表比对</span></span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val!=stk.<span class="built_in">top</span>()-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015171204192.png" alt="image-20231015171204192"></p>
<p><strong>第二种解法：快慢指针+栈，空间复杂度O(N)</strong></p>
<blockquote>
<p>借助栈结构和双指针，一个指针的位移为1并将此时访问的元素放到栈中，另一个指针的位移为2，当位移为2的指针到达末尾时，位移为1的指针到达链表中间位置。此后将栈中元素与链表中元素值比对。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法二，利用栈+快慢指针 O(n/2)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome2</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;ListNode*&gt; stk;</span><br><span class="line">    <span class="comment">//使用双指针</span></span><br><span class="line">    ListNode* right=head-&gt;next;</span><br><span class="line">    ListNode* cur=head;</span><br><span class="line">    <span class="comment">// cur走两步,right 走到中点</span></span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next!=<span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next !=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        right=right-&gt;next;</span><br><span class="line">        </span><br><span class="line">        cur=cur-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩下的压入栈</span></span><br><span class="line">    <span class="keyword">while</span> (right)</span><br><span class="line">    &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(right);</span><br><span class="line">        </span><br><span class="line">        right=right-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比对前半与后半</span></span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val!=stk.<span class="built_in">top</span>()-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015171506049.png" alt="image-20231015171506049"></p>
<p><strong>第三种解法：只用快慢指针，麻烦，一般笔试不要写，浪费时间，空间复杂度O(1)</strong></p>
<blockquote>
<p>利用快慢指针找到中间，然后将中间指向null，将后半部分逆序，最后比对</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231013112527196.png" alt="image-20231013112527196"></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231013112548129.png" alt="image-20231013112548129"></p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法三：利用快慢指针 O(1)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome3</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* p1=head;</span><br><span class="line">    ListNode* p2=head;</span><br><span class="line">    <span class="comment">// p1走到中间，p2走到最后</span></span><br><span class="line">    <span class="keyword">while</span> (p2-&gt;next!=<span class="literal">nullptr</span> &amp;&amp; p2-&gt;next-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">        p2=p2-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p2=p1-&gt;next; </span><br><span class="line">    p1-&gt;next=<span class="literal">nullptr</span>; <span class="comment">//将中间指向null</span></span><br><span class="line">    ListNode* p3=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//将后半部分逆序</span></span><br><span class="line">    <span class="keyword">while</span> (p2!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p3=p2-&gt;next;<span class="comment">//记录下一个</span></span><br><span class="line">        p2-&gt;next=p1;<span class="comment">//将指针反转</span></span><br><span class="line">        <span class="comment">//两个指针往后移</span></span><br><span class="line">        p1=p2;</span><br><span class="line">        p2=p3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将p3指向后半部分的头，p2指向前半部分的头进行比对</span></span><br><span class="line">    p3=p1;</span><br><span class="line">    p2=head;</span><br><span class="line">    <span class="type">bool</span> res=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1!=<span class="literal">nullptr</span> &amp;&amp; p2!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val!=p2-&gt;val)&#123;</span><br><span class="line">            res=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    p1=p3-&gt;next;</span><br><span class="line">    p3-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1!=<span class="literal">nullptr</span>)<span class="comment">//将后半部分逆序回来</span></span><br><span class="line">    &#123;</span><br><span class="line">        p2=p1-&gt;next;</span><br><span class="line">        p1-&gt;next=p3;</span><br><span class="line">        p3=p1;</span><br><span class="line">        p1=p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231015171830155.png" alt="image-20231015171830155"></p>
<h4 id="四、将单向链表按某值划分为左边小、中间相等、右边大的形式（分隔链表）"><a href="#四、将单向链表按某值划分为左边小、中间相等、右边大的形式（分隔链表）" class="headerlink" title="四、将单向链表按某值划分为左边小、中间相等、右边大的形式（分隔链表）"></a>四、将单向链表按某值划分为左边小、中间相等、右边大的形式（分隔链表）</h4><p><strong>题目</strong>：给定一个单链表的头节点head，节点的值类型是整型，再给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。</p>
<img src="/MyBlog/.io//image-20231015102642956.png" alt="image-20231015102642956" style="zoom: 80%;">



<blockquote>
<p>法一：利用数组partition，将链表放入数组中，将数组分割成大于、小于、等于，再将数组中的结点串起来</p>
<p>法二：分割链表，将链表分成三部分，分别为大于、小于、等于，将这三个链表头尾相连即可。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">listPartition2</span><span class="params">(ListNode* head,<span class="type">int</span> pivot)</span></span>&#123;</span><br><span class="line">    ListNode* SH=<span class="literal">nullptr</span>; <span class="comment">// 创建三条链表，有头和尾节点</span></span><br><span class="line">    ListNode* ST=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* EH=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* ET=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* MH=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* MT=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* next=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) <span class="comment">//遍历初始链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        next=head-&gt;next; <span class="comment">//保存下一结点</span></span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>; <span class="comment">//将当前结点取出，判断接到那条链表上</span></span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val&lt;pivot)&#123;</span><br><span class="line">            <span class="keyword">if</span>(SH==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                SH=head;</span><br><span class="line">                ST=head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ST-&gt;next=head;</span><br><span class="line">                ST=head;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (head-&gt;val==pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(EH==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                EH=head;</span><br><span class="line">                ET=head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ET-&gt;next=head;</span><br><span class="line">                ET=head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(MH==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                MH=head;</span><br><span class="line">                MT=head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                MT-&gt;next=head;</span><br><span class="line">                MT=head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head=next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将链表互相之间连接</span></span><br><span class="line">    <span class="keyword">if</span>(ST!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            ST-&gt;next=EH;</span><br><span class="line">            ET=ET==<span class="literal">nullptr</span>?ST:ET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ET!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ET-&gt;next=MH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SH!=<span class="literal">nullptr</span>?SH:(EH!=<span class="literal">nullptr</span>?EH:MH);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="五、复制含有随机指针节点的链表"><a href="#五、复制含有随机指针节点的链表" class="headerlink" title="五、复制含有随机指针节点的链表"></a>五、复制含有随机指针节点的链表</h4><p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231013114516279.png" alt="image-20231013114516279"></p>
<p>链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/solutions/2361362/138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-b-6jeo/">138. 随机链表的复制 - 力扣（LeetCode）</a></p>
<p><strong>法一： 哈希表</strong></p>
<blockquote>
<p>利用哈希表，拷贝一个新链表，并建立映射关系，再遍历构建新链表各节点的<code>next</code>和<code>random</code>引用指向即可。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/1604747285-lmVIhC-Picture8.png" alt="img"></p>
</blockquote>
<p><strong>代码如下</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyListWithRand1</span><span class="params">(Node* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;Node*,Node*&gt; map; <span class="comment">//建立哈希表</span></span><br><span class="line">    Node* cur=head;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="literal">nullptr</span>) <span class="comment">//拷贝新链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        map[cur]=<span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur=head;</span><br><span class="line">    <span class="keyword">while</span>(cur !=<span class="literal">nullptr</span>)&#123;<span class="comment">//从头开始遍历将每个新链表与旧链表引用对应</span></span><br><span class="line">        map[cur]-&gt;next=map[cur-&gt;next];<span class="comment">//拷贝节点的下一个是原节点下一个的拷贝</span></span><br><span class="line">        map[cur]-&gt;random=map[cur-&gt;random];<span class="comment">//拷贝节点的随机指针是原节点随机指针的拷贝</span></span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>法二：拼接+拆分</strong></p>
<blockquote>
<p>考虑构建 <code>原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2 -&gt; …… </code>的拼接链表，如此便可在访问原节点的 <code>random</code> 指向节点的同时找到新对应新节点的 <code>random</code> 指向节点。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/1604747742-aMDdkM-Picture14.png" alt="img"></p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyListWithRand2</span><span class="params">(Node* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="comment">// 1. 复制各节点，并构建拼接链表</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Node* tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            tmp-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = tmp;</span><br><span class="line">            cur = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 构建各新节点的 random 指向</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;random != <span class="literal">nullptr</span>)</span><br><span class="line">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 拆分两链表</span></span><br><span class="line">        cur = head-&gt;next;</span><br><span class="line">        Node* pre = head, *res = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 单独处理原链表尾节点</span></span><br><span class="line">        <span class="keyword">return</span> res;      <span class="comment">// 返回新链表头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="六、两个单链表相交的一系列问题"><a href="#六、两个单链表相交的一系列问题" class="headerlink" title="六、两个单链表相交的一系列问题"></a>六、两个单链表相交的一系列问题</h4><p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231013114712155.png" alt="image-20231013114712155"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getIntersectNode</span><span class="params">(ListNode* head1,ListNode*head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1==<span class="literal">nullptr</span>||head2==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* loop1=<span class="built_in">getLoopNode</span>(head1);</span><br><span class="line">    ListNode* loop2=<span class="built_in">getLoopNode</span>(head2);</span><br><span class="line">    <span class="keyword">if</span> (loop1==<span class="literal">nullptr</span>&amp;&amp;loop2==<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">noLoop</span>(head1,head2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loop1!=<span class="literal">nullptr</span>&amp;&amp;loop2!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bothLoop</span>(head1,loop1,head2,loop2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否有环，如果无环，返回null，如果有环，返回入环节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">getLoopNode</span><span class="params">(ListNode* head)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>|| head-&gt;next==<span class="literal">nullptr</span>||head-&gt;next-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">//三个节点以上才能形成环</span></span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* n1=head-&gt;next; <span class="comment">//快慢指针</span></span><br><span class="line">    ListNode* n2=head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(n1!=n2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n2-&gt;next==<span class="literal">nullptr</span>||n2-&gt;next-&gt;next==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n2=n2-&gt;next-&gt;next;</span><br><span class="line">        n1=n1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    n2=head;</span><br><span class="line">    <span class="keyword">while</span> (n1!=n2) <span class="comment">//n2 会到头节点重走一遍，最后n1、n2在入环结点相遇</span></span><br><span class="line">    &#123;</span><br><span class="line">        n1=n1-&gt;next;</span><br><span class="line">        n2=n2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个无环链表的相交节点，如果有返回第一个相交节点，如果无则返回null</span></span><br><span class="line"><span class="function">ListNode* <span class="title">noLoop</span><span class="params">(ListNode* head1,ListNode* head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1==<span class="literal">nullptr</span>||head2==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* cur1=head1;</span><br><span class="line">    ListNode* cur2=head2;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1-&gt;next)<span class="comment">//找链表1的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        cur1=cur1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur2-&gt;next)<span class="comment">//找链表2的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        n--;</span><br><span class="line">        cur2=cur2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur1!=cur2)&#123;<span class="comment">//无环链表如果相交最好肯定结点相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cur1=n&gt;<span class="number">0</span>?head1:head2; <span class="comment">//谁长令谁为cur1</span></span><br><span class="line">    cur2=cur1==head1?head2:head1; <span class="comment">//谁短令谁为cur2</span></span><br><span class="line">    n=<span class="built_in">abs</span>(n);   </span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;<span class="comment">//长的先走长度差值</span></span><br><span class="line">        n--;</span><br><span class="line">        cur1=cur1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur1!=cur2) <span class="comment">//两指针一起走有环总会遇到</span></span><br><span class="line">    &#123;</span><br><span class="line">        cur1=cur1-&gt;next;</span><br><span class="line">        cur2=cur2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个有环链表和一个无环链表 不可能相交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个有环链表的相交结点，如果有返回第一个相交节点，如果无则返回null</span></span><br><span class="line"><span class="function">ListNode* <span class="title">bothLoop</span><span class="params">(ListNode* head1,ListNode*loop1,ListNode* head2,ListNode* loop2)</span></span>&#123;</span><br><span class="line">    ListNode* cur1=<span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur2=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(loop1==loop2)&#123; <span class="comment">//如果两链表入环节点相同，则说明他们至少在入环前相交,则方式跟无环相同</span></span><br><span class="line">        cur1=head1;</span><br><span class="line">        cur2=head2;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1!=loop1)<span class="comment">// 找链表1到入环节点的长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            n++;</span><br><span class="line">            cur1=cur1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2!=loop2)<span class="comment">// 找链表2到入环节点的长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            n--;</span><br><span class="line">            cur2=cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1=n&gt;<span class="number">0</span>?head1:head2; <span class="comment">//谁长令谁为cur1</span></span><br><span class="line">        cur2=cur1==head1?head2:head1; <span class="comment">//谁短令谁为cur2</span></span><br><span class="line">        n=<span class="built_in">abs</span>(n);   </span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;<span class="comment">//长的先走长度差值</span></span><br><span class="line">            n--;</span><br><span class="line">            cur1=cur1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur1!=cur2) <span class="comment">//两指针一起走有环总会遇到</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur1=cur1-&gt;next;</span><br><span class="line">            cur2=cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//两链表入环节点不同</span></span><br><span class="line">        cur1=loop1-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur1!=loop1) <span class="comment">//入环后一定能与链表2的入环节点相遇</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1==loop2)&#123;</span><br><span class="line">                <span class="keyword">return</span> loop1; <span class="comment">//返回loop1 loop2都行,</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur1=cur1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="七、合并k个升序链表"><a href="#七、合并k个升序链表" class="headerlink" title="七、合并k个升序链表"></a>七、合并k个升序链表</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">23. 合并 K 个升序链表 - 力扣（LeetCode）</a></p>
<h2 id="四、栈和队列"><a href="#四、栈和队列" class="headerlink" title="四、栈和队列"></a>四、栈和队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h3 id="1、栈的基本概念"><a href="#1、栈的基本概念" class="headerlink" title="1、栈的基本概念"></a>1、栈的基本概念</h3><p><strong>栈</strong>（Stack）：是只允许在一端进行插入或删除的<strong>线性表</strong>。首先栈是一种<strong>线性表</strong>，但限定这种线性表只能在某一端进行插入和删除操作。</p>
<p><strong>栈顶</strong>（Top）：线性表允许进行插入删除的那一端。<br><strong>栈底</strong>（Bottom）：固定的，不允许进行插入和删除的另一端。<br><strong>空栈</strong>：不含任何元素的空表。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210218204524571.png" alt="在这里插入图片描述"></p>
<h3 id="2、栈的顺序存储结构"><a href="#2、栈的顺序存储结构" class="headerlink" title="2、栈的顺序存储结构"></a>2、栈的顺序存储结构</h3><p>采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。</p>
<h4 id="自己定义栈"><a href="#自己定义栈" class="headerlink" title="自己定义栈"></a>自己定义栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 50</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="built_in">Stack</span>():<span class="built_in">top</span>(<span class="number">-1</span>)&#123;&#125; <span class="comment">//可用构造函数初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(Stack *S)</span></span>&#123;  <span class="comment">//可以用函数初始化</span></span><br><span class="line">    S-&gt;top=<span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(Stack *S)</span></span>&#123; <span class="comment">//判断栈空</span></span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(Stack *S,<span class="type">int</span> e)</span></span>&#123; <span class="comment">//进栈</span></span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==MAXSIZE<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;top++;</span><br><span class="line">    S-&gt;data[S-&gt;top]=e;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">(Stack *S,<span class="type">int</span> *e)</span></span>&#123; <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *e =S-&gt;data[S-&gt;top];</span><br><span class="line">    S-&gt;top--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetTop</span><span class="params">(Stack *S,<span class="type">int</span> *e)</span></span>&#123; <span class="comment">//栈顶</span></span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top == <span class="number">-1</span>)&#123;   <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = S-&gt;data[S-&gt;top];   <span class="comment">//记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> *e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="STL库中的栈"><a href="#STL库中的栈" class="headerlink" title="STL库中的栈"></a>STL库中的栈</h4><blockquote>
<p><strong>#include&lt;stack&gt;</strong> 头文件</p>
<p><strong>s.top()</strong> &#x2F;&#x2F;返回栈顶元素<br><strong>s.push()</strong> &#x2F;&#x2F; 在栈顶压入一个元素<br><strong>s.pop()</strong> &#x2F;&#x2F; 弹出栈顶元素<br><strong>s.size()</strong> &#x2F;&#x2F;返回栈中元素的个数<br><strong>s.empty()</strong> &#x2F;&#x2F;判断栈是否为空栈</p>
</blockquote>
<h3 id="3、栈的链式存储结构"><a href="#3、栈的链式存储结构" class="headerlink" title="3、栈的链式存储结构"></a>3、栈的链式存储结构</h3><p><strong>采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头节点，Lhead指向栈顶元素</strong>，如下图所示。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/2021021910502017.png" alt="在这里插入图片描述"></p>
<p><strong>对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top&#x3D;NULL的时候。</strong></p>
<p>链栈的结构代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*栈的链式存储结构*/</span></span><br><span class="line"><span class="comment">/*构造节点*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StackNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StackNode</span> *next;</span><br><span class="line">&#125;StackNode, *LinkStackPrt;</span><br><span class="line"><span class="comment">/*构造链栈*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkStack</span>&#123;</span><br><span class="line">    LinkStackPrt top;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入元素e为新的栈顶元素*/</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack *S, ElemType e)</span></span>&#123;</span><br><span class="line">    LinkStackPrt p = (LinkStackPrt)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(StackNode));</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S-&gt;top;    <span class="comment">//把当前的栈顶元素赋值给新节点的直接后继</span></span><br><span class="line">    S-&gt;top = p; <span class="comment">//将新的结点S赋值给栈顶指针</span></span><br><span class="line">    S-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack *S, ElemType *e)</span></span>&#123;</span><br><span class="line">    LinkStackPtr p;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(*S))&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = S-&gt;top-&gt;data;</span><br><span class="line">    p = S-&gt;top; <span class="comment">//将栈顶结点赋值给p</span></span><br><span class="line">    S-&gt;top = S-&gt;top-&gt;next;  <span class="comment">//使得栈顶指针下移一位，指向后一结点</span></span><br><span class="line">    <span class="built_in">free</span>(p);    <span class="comment">//释放结点p</span></span><br><span class="line">    S-&gt;count--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4、栈的应用"><a href="#4、栈的应用" class="headerlink" title="4、栈的应用"></a>4、栈的应用</h3><h4 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h4><p><strong>1、递归的定义</strong><br><strong>递归是一种重要的程序设计方法。简单地说,若在一个函数、过程或数据结构的定义中又应用了它自身,则这个函数、过程或数据结构称为是递归定义的,简称递归</strong>。<br>它通常把一个大型的复杂问题层层转化为一个与原问题相似的规模较小的问题来求解,递归策略只需少量的代码就可以描述岀解题过程所需要的多次重复计算,大大减少了程序的代码量但在通常情况下,它的效率并不是太高。</p>
<h4 id="二、四则运算表达式"><a href="#二、四则运算表达式" class="headerlink" title="二、四则运算表达式"></a>二、四则运算表达式</h4><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="1-队列的基本概念"><a href="#1-队列的基本概念" class="headerlink" title="1.队列的基本概念"></a>1.队列的基本概念</h4><p><strong>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</strong><br>队列是一种先进先出（First In First Out）的线性表，简称FIFO。&#x3D;&#x3D;允许插入&#x3D;&#x3D;的一端称为&#x3D;&#x3D;队尾&#x3D;&#x3D;，&#x3D;&#x3D;允许删除&#x3D;&#x3D;的一端称为队头。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210219144731888.png" alt="在这里插入图片描述"></p>
<h4 id="2-队列的顺序存储结构"><a href="#2-队列的顺序存储结构" class="headerlink" title="2.队列的顺序存储结构"></a>2.队列的顺序存储结构</h4><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针 front指向队头元素，队尾指针 rear 指向队尾元素的下一个位置。</p>
<h5 id="1、顺序队列"><a href="#1、顺序队列" class="headerlink" title="1、顺序队列"></a>1、顺序队列</h5><p>队列的顺序存储类型可描述为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 50	<span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType data[MAXSIZE];	<span class="comment">//存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front,rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<p>初始状态（队空条件）：<code>Q-&gt;front == Q-&gt;rear == 0</code>。<br>进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。<br>出队操作：队不空时，先取队头元素值，再将队头指针加1。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210219152051156.png" alt="在这里插入图片描述"></p>
<p>如图d，队列出现“上溢出”，然而却又不是真正的溢出，所以是一种“假溢出”。</p>
<h4 id="3-STL库中的队列"><a href="#3-STL库中的队列" class="headerlink" title="3.STL库中的队列"></a>3.STL库中的队列</h4><blockquote>
<p>#include&lt;queue&gt;  头文件</p>
<p>empty() 检测队列是否为空，是返回true，否则返回false</p>
<p>size() 返回队列中有效元素的个数</p>
<p>front() 返回队头元素的引用</p>
<p>back() 返回队尾元素的引用</p>
<p>push() 在队尾将元素val入队列</p>
<p>pop() 将队头元素出队列</p>
</blockquote>
<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><h4 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h4><blockquote>
<p>优先队列：顾名思义，首先它是一个队列，但是它强调了“优先”二字，所以，已经不能算是一般意义上的队列了，它的“优先”意指取队首元素时，有一定的选择性，&#x3D;&#x3D;即根据元素的属性选择某一项值最优的出队&#x3D;&#x3D;</p>
<p>优先级队列是一个拥有权值观念的queue。它允许在底端添加元素、在顶端去除元素、删除元素。 缺省情况下，优先级队列利用一个大顶堆完成。</p>
</blockquote>
<h4 id="二、二叉堆"><a href="#二、二叉堆" class="headerlink" title="二、二叉堆"></a>二、二叉堆</h4><p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231202134355543.png" alt="image-20231202134355543"></p>
<p>我们设树的根结点为0，给定一个下标i，可以很容易计算得到它的父节点、左孩子、右孩子的下标。<br>$$<br>(从0出发)i的\begin{cases}<br>父结点&amp;\frac {i-1}2\<br>左孩子&amp;2\times i+1\<br>右孩子&amp;2\times i+2<br>\end{cases}<br>$$</p>
<h5 id="二叉堆的操作"><a href="#二叉堆的操作" class="headerlink" title="二叉堆的操作"></a>二叉堆的操作</h5><h4 id="堆的拓展"><a href="#堆的拓展" class="headerlink" title="堆的拓展"></a>堆的拓展</h4><h5 id="1、双端优先级队列"><a href="#1、双端优先级队列" class="headerlink" title="1、双端优先级队列"></a>1、双端优先级队列</h5><h5 id="2、对顶堆"><a href="#2、对顶堆" class="headerlink" title="2、对顶堆"></a>2、对顶堆</h5><h4 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h4><h5 id="K个最小元素和"><a href="#K个最小元素和" class="headerlink" title="K个最小元素和"></a>K个最小元素和</h5><p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231120105752723.png" alt="image-20231120105752723"></p>
<blockquote>
<p><strong>法一：插入排序</strong></p>
<p>利用排序，每次将最大的元素去掉，再插入下一个元素</p>
<p><strong>法二：堆</strong></p>
<p>利用最大堆，每次将最大的元素去掉，再插入下一个元素</p>
</blockquote>
<h3 id="栈和队列的题"><a href="#栈和队列的题" class="headerlink" title="栈和队列的题"></a>栈和队列的题</h3><h4 id="1-用栈实现队列"><a href="#1-用栈实现队列" class="headerlink" title="1.用栈实现队列"></a>1.用栈实现队列</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/solutions/656774/tu-jie-guan-fang-tui-jian-ti-jie-yong-zh-4hru/">232. 用栈实现队列 - 力扣（LeetCode）</a></p>
<blockquote>
<p>队列是一种先入先出（FIFO）的数据结构，而栈是一种后入先出（LIFO）的数据结构，所以一个栈绝对满足不了队列的 FIFO 的特性。</p>
<p>比如 1 2 3，队列 1 2 3 进，应该 1 2 3 出，但是 1 2 3 进了栈，出来以后会成 3 2 1，和 1 2 3 是相反的，所以再需要一个栈，把 3 2 1 返成 1 2 3。</p>
<p>因此这里需要两个栈，分别是<strong>输入栈和输出栈：</strong></p>
<p><strong>输入栈来反转元素的入队顺序，元素入只能从输入栈进（push）。</strong></p>
<p><strong>输出栈用来存储元素的正常顺序，元素出只能从输出栈出（pop、peek）。</strong></p>
</blockquote>
<p><strong>图解</strong></p>
<p><img src="/MyBlog/.io//1642039117-gbDJZG-20220102_172137631_0.jpg" alt="bf0649d5850c6b0c488bb41481731da" style="zoom:90%;"><img src="/MyBlog/.io//1642039117-XajbyA-20220102_172210106_0.jpg" alt="ec707d02f08a529375faac008c73d12" style="zoom:90%;"></p>
<img src="/MyBlog/.io//1642039117-gwoxWy-20220102_172240157_0.jpg" alt="78c2da16f1bd9221e94bb4f23d46201" style="zoom:90%;">

<p><strong>代码如下</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; inStack,outStack;<span class="comment">//定义输入栈和输出栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">in2out</span><span class="params">()</span></span>&#123;<span class="comment">//将输入栈中的元素转到输出栈中</span></span><br><span class="line">        <span class="keyword">while</span>(!inStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            outStack.<span class="built_in">push</span>(inStack.<span class="built_in">top</span>());</span><br><span class="line">            inStack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="built_in">in2out</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x=outStack.<span class="built_in">top</span>();</span><br><span class="line">        outStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="built_in">in2out</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x=outStack.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outStack.<span class="built_in">empty</span>()&amp;&amp;inStack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-用队列实现栈"><a href="#2-用队列实现栈" class="headerlink" title="2.用队列实现栈"></a>2.用队列实现栈</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/solutions/432204/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/">225. 用队列实现栈 - 力扣（LeetCode）</a></p>
<p><strong>法一：用两个队列</strong></p>
<blockquote>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/225_fig1.gif" alt="fig1"></p>
</blockquote>
<p><strong>法二：一个队列</strong></p>
<blockquote>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/225_fig2.gif" alt="fig2"></p>
</blockquote>
<h2 id="五、二叉树"><a href="#五、二叉树" class="headerlink" title="五、二叉树"></a>五、二叉树</h2><h3 id="一、定义-1"><a href="#一、定义-1" class="headerlink" title="一、定义"></a>一、定义</h3><p>普通定义：二叉树是每个节点<strong>最多只有两个子树</strong>的数结构，两个子树称为左子树和右子树。<br>递归定义：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树。</p>
<h3 id="二、性质"><a href="#二、性质" class="headerlink" title="二、性质"></a>二、性质</h3><blockquote>
<ol>
<li><p><strong>任意二叉树第i层最大结点数为$2^{i-1}。(i\ge 1)$</strong></p>
<p>归纳法证明。</p>
</li>
<li><p><strong>深度为k的二叉树最大结点总数为$$2^k-1。(k\ge 1)$$</strong></p>
<p>证明：$\sum^k_{i&#x3D;1}2^{i-1}&#x3D;2^k-1$</p>
</li>
<li><p><strong>对于任意二叉树，用$n_0,n_1,n_2$分别表示叶子结点，度为1的结点，度为2的结点的个数，则有关系式$n_0&#x3D;n_2+1$</strong></p>
<p>证明：总结点个数$n&#x3D;n_0+n_1+n_2$；总结点中除根结点外，其余各结点都有一个分支进入，设m为分支总数，则有$n&#x3D;m+1$，又因为这些分支都是由度为1或2的结点射出的，所以有$m&#x3D;n_1+2n_2$，于是有$n&#x3D;n_1+2n_2+1$;最后将关于n的两个关系式化简得证。</p>
</li>
<li><p><strong>n个结点&#x3D;&#x3D;完全二叉树&#x3D;&#x3D;深度为$\lfloor log_2n\rfloor +1$</strong></p>
<p>证明：设深度k，则有$2^{k-1}\le n&lt;2^k\Rightarrow k-1\le log_2n&lt;k\Rightarrow&#x3D;\lfloor log_2n\rfloor +1 $</p>
</li>
<li><p><strong>性质5其实描述的是完全二叉树中父子结点间的逻辑对应关系。</strong> 假如对一棵&#x3D;&#x3D;完全二叉树&#x3D;&#x3D;的所有顶点按层序遍历的顺序从1开始编号,对于编号后的结点$i$ ：</p>
<p>(1)i&#x3D;1时表示i是根结点；</p>
<p>(2)i&gt;1时：①i的根结点为$\frac{i}2$。②若$2 i &gt; n $，结点i 无左孩子，且为叶子结点。③若$2 i + 1 &gt; n$ ，结点i无右孩子，可能为叶子结点。<br>当然如果完全二叉树的顶点从0开始编号，那么上述关系就要相应修改一下。</p>
</li>
</ol>
</blockquote>
<h3 id="三、二叉树的形态"><a href="#三、二叉树的形态" class="headerlink" title="三、二叉树的形态"></a>三、二叉树的形态</h3><p><strong>五种基本形态</strong></p>
<p>从上面二叉树的递归定义可以看出，二叉树或为空，或为一个根结点加上两棵左右子树，因为两棵左右子树也是二叉树也可以为空，所以二叉树有5种基本形态：<br><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20200330145137194.png" alt="在这里插入图片描述"></p>
<p><strong>三种特殊形态</strong><br><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20200330145319114.png" alt="在这里插入图片描述"></p>
<p><strong>满二叉树</strong>：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是$(2^k) -1 $，则它就是满二叉树。<br><strong>完全二叉树</strong>：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。&#x3D;&#x3D;要注意的是满二叉树是一种特殊的完全二叉树&#x3D;&#x3D;</p>
<p><strong>完美二叉树</strong>：所有叶节点在同一层</p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="1-顺序存储"><a href="#1-顺序存储" class="headerlink" title="1.顺序存储"></a>1.顺序存储</h4><blockquote>
<p>顺序结构存储就是使用&#x3D;&#x3D;数组&#x3D;&#x3D;来存储，一般使用数组&#x3D;&#x3D;只适合表示完全二叉树&#x3D;&#x3D;，因为不是完全二叉树会有空间的浪费。而现实中使用中只有堆才会使用数组来存储。二叉树顺序存储在物理上是一个数组，在逻辑上是一颗二叉树。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5NjM4Nw==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
</blockquote>
<h4 id="2-链式存储"><a href="#2-链式存储" class="headerlink" title="2.链式存储"></a>2.链式存储</h4><blockquote>
<p>二叉树的链式存储结构是指，&#x3D;&#x3D;用链表来表示一棵二叉树&#x3D;&#x3D;，即用链来指示元素的逻辑关系。 通常的方法是链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程学到高阶数据结构如红黑树等会用到三叉链。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5NjM4Nw==,size_16,color_FFFFFF,t_70-16988967379045.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="二叉树的建立与操作"><a href="#二叉树的建立与操作" class="headerlink" title="二叉树的建立与操作"></a>二叉树的建立与操作</h3><p>&#x3D;&#x3D;类似于链表&#x3D;&#x3D;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    <span class="built_in">TreeNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>),<span class="built_in">left</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">right</span>(<span class="literal">nullptr</span>),<span class="built_in">left</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x,TreeNode*left,TreeNode*right):<span class="built_in">val</span>(x),<span class="built_in">left</span>(left),<span class="built_in">right</span>(right)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="深度优先遍历，递归序"><a href="#深度优先遍历，递归序" class="headerlink" title="深度优先遍历，递归序"></a>深度优先遍历，递归序</h4><blockquote>
<p>深度优先遍历有三种方案，前序，中序，后序</p>
<p><font size="5"><strong>深度优先遍历每个结点都能到自己3次</strong></font></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231026100526601.png" alt="image-20231026100526601"></p>
<p><font size="5"><strong>可以由递归序得先序中序后序</strong></font></p>
<p><strong>先序是递归序中第一次出现的结点</strong></p>
<p><strong>中序是递归序中第二次出现的结点</strong></p>
<p><strong>后序是递归序中第三次出现的结点</strong></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231026100740356.png" alt="image-20231026100740356"></p>
</blockquote>
<h4 id="1-先序遍历-根左右"><a href="#1-先序遍历-根左右" class="headerlink" title="1. 先序遍历(根左右)"></a>1. 先序遍历(根左右)</h4><blockquote>
<p>先序遍历可以想象为，一个小人从一棵二叉树根节点为起点，沿着二叉树外沿，逆时针走一圈回到根节点，路上遇到的元素顺序，就是先序遍历的结果</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/202012091634524.gif" alt="在这里插入图片描述"></p>
</blockquote>
<p>&#x3D;&#x3D;先序遍历结果为：A B D H I E J C F K G&#x3D;&#x3D;</p>
<h4 id="2-中序遍历（左根右）"><a href="#2-中序遍历（左根右）" class="headerlink" title="2.中序遍历（左根右）"></a>2.中序遍历（左根右）</h4><blockquote>
<p>中序遍历可以看成，二叉树每个节点，垂直方向投影下来（可以理解为每个节点从最左边开始垂直掉到地上），然后从左往右数，得出的结果便是中序遍历的结果</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20201209164211397.gif" alt="在这里插入图片描述"></p>
</blockquote>
<p>&#x3D;&#x3D;中序遍历结果为：H D I B E J A F K C G&#x3D;&#x3D;</p>
<h4 id="3-后序遍历（左右根）"><a href="#3-后序遍历（左右根）" class="headerlink" title="3.后序遍历（左右根）"></a>3.后序遍历（左右根）</h4><blockquote>
<p>后序遍历就像是&#x3D;&#x3D;剪葡萄，我们要把一串葡萄剪成一颗一颗的。&#x3D;&#x3D;</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/2020120916532175.gif" alt="在这里插入图片描述"></p>
</blockquote>
<p>&#x3D;&#x3D;后序遍历结果：H I D J E B K F G C A&#x3D;&#x3D;</p>
<p><strong>代码如下：</strong></p>
<p>使用递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用递归的先序、中序、后序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderRecur</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;head-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">PreOrderRecur</span>(head-&gt;left);</span><br><span class="line">    <span class="built_in">PreOrderRecur</span>(head-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderRecur</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InOrderRecur</span>(head-&gt;left);</span><br><span class="line">    cout&lt;&lt;head-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">InOrderRecur</span>(head-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PosOrderRecur</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PosOrderRecur</span>(head-&gt;left);</span><br><span class="line">    <span class="built_in">PosOrderRecur</span>(head-&gt;right);</span><br><span class="line">    cout&lt;&lt;head-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>不使用递归，自己压栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用非递归,自己压栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderUnRecur</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(head);</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        head=stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        cout&lt;&lt;head-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head-&gt;right!=<span class="literal">nullptr</span>)&#123; <span class="comment">//先压右孩子，后出</span></span><br><span class="line">            stk.<span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;left!=<span class="literal">nullptr</span>)&#123; <span class="comment">//后压左孩子，先出</span></span><br><span class="line">            stk.<span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderUnRecur</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()||head!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="literal">nullptr</span>)&#123; <span class="comment">//一直找左孩子，直到为空</span></span><br><span class="line">            stk.<span class="built_in">push</span>(head);</span><br><span class="line">            head=head-&gt;left;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;  <span class="comment">//找右孩子</span></span><br><span class="line">            head=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            cout&lt;&lt;head-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            head=head-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PosOrderUnRecur</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个栈，</span></span><br><span class="line">    stack&lt;TreeNode*&gt; stk1;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk2;</span><br><span class="line">    stk<span class="number">1.</span><span class="built_in">push</span>(head);</span><br><span class="line">    <span class="keyword">while</span> (!stk<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        head=stk<span class="number">1.</span><span class="built_in">top</span>();</span><br><span class="line">        stk<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">        stk<span class="number">2.</span><span class="built_in">push</span>(head);</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            stk<span class="number">1.</span><span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            stk<span class="number">1.</span><span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stk<span class="number">2.</span><span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout&lt;&lt;stk<span class="number">2.</span><span class="built_in">top</span>()-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            stk<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-层次遍历（宽度优先遍历）：使用队列"><a href="#4-层次遍历（宽度优先遍历）：使用队列" class="headerlink" title="4.层次遍历（宽度优先遍历）：使用队列"></a>4.层次遍历（宽度优先遍历）：使用队列</h4><blockquote>
<p>层次遍历（宽度优先遍历）很好理解，就是从根节点开始，一层一层，从上到下，每层从左到右，依次写值就可以了，层次遍历用队列</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaW5lc2Vrb2Jl,size_16,color_FFFFFF,t_70-16980278373319.png" alt="在这里插入图片描述"></p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宽度优先遍历，使用队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">widthTraversal</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(head);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* cur=q.<span class="built_in">front</span>(); <span class="comment">//一层一层弹出</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout&lt;&lt;cur-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123; <span class="comment">//先进左结点，先出</span></span><br><span class="line">            q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;<span class="comment">//先进右结点，后出</span></span><br><span class="line">            q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="求一颗二叉树的宽度（宽度优先遍历）"><a href="#求一颗二叉树的宽度（宽度优先遍历）" class="headerlink" title="求一颗二叉树的宽度（宽度优先遍历）"></a>求一颗二叉树的宽度（宽度优先遍历）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">treeWidth</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(head);</span><br><span class="line">    unordered_map&lt;TreeNode*,<span class="type">int</span>&gt; levelMap;</span><br><span class="line">    levelMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;TreeNode*,<span class="type">int</span>&gt;(head,<span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> curLevel=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> curLevelNodes=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> Max=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* cur=q.<span class="built_in">front</span>(); <span class="comment">//一层一层弹出</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> curNodeLevel=levelMap[cur]; <span class="comment">//获取当前节点的层数</span></span><br><span class="line">        <span class="keyword">if</span>(curNodeLevel==curLevel)&#123;   <span class="comment">//如果当前节点的层数是该层，则结点数加1</span></span><br><span class="line">            curLevelNodes++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;   <span class="comment">//否则，更新结点数的最大值，并层数+1，当前节点个数为1.</span></span><br><span class="line">            Max=<span class="built_in">max</span>(Max,curLevelNodes);</span><br><span class="line">            curLevel++;</span><br><span class="line">            curLevelNodes=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123; <span class="comment">//先进左结点，先出</span></span><br><span class="line">            levelMap.<span class="built_in">emplace</span>(cur-&gt;left,curNodeLevel<span class="number">+1</span>); <span class="comment">//记录孩子的层数</span></span><br><span class="line">            q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;<span class="comment">//先进右结点，后出</span></span><br><span class="line">            levelMap.<span class="built_in">emplace</span>(cur-&gt;right,curNodeLevel<span class="number">+1</span>); <span class="comment">//记录孩子的层数</span></span><br><span class="line">            q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        Max=<span class="built_in">max</span>(Max,curLevelNodes);<span class="comment">//最后一层再比较一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二叉树遍历的应用"><a href="#二叉树遍历的应用" class="headerlink" title="二叉树遍历的应用"></a>二叉树遍历的应用</h4><h5 id="1-奇偶数Ⅰ"><a href="#1-奇偶数Ⅰ" class="headerlink" title="1.奇偶数Ⅰ"></a>1.奇偶数Ⅰ</h5><p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231109102325366.png" alt="image-20231109102325366"></p>
<blockquote>
<p><strong>法一：层序遍历——利用队列</strong></p>
<p>从上至下依层遍历所有结点，同时记录结点所在层数</p>
<p><strong>（1）结点队列：记录结点</strong></p>
<p><strong>（2）层数队列：记录结点所在层</strong></p>
<p>然后对出队结点判断其元素值及层数的奇偶性是否一致</p>
<p><strong>法二：前序遍历</strong></p>
<p>把层数作为参数传递</p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isParityTree</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt;node_queue; <span class="comment">//结点队列</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;level_queue; <span class="comment">//结点所在层数队列</span></span><br><span class="line">    node_queue.<span class="built_in">push</span>(head);</span><br><span class="line">    level_queue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(!node_queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode* node_ptr=node_queue.<span class="built_in">front</span>();</span><br><span class="line">        node_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> level=level_queue.<span class="built_in">front</span>();</span><br><span class="line">        level_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(node_ptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node_ptr-&gt;val%<span class="number">2</span>!=level%<span class="number">2</span>)&#123;<span class="comment">// 判断奇偶性是否相同</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node_queue.<span class="built_in">push</span>(node_ptr-&gt;left); <span class="comment">//压入左孩子</span></span><br><span class="line">            level_queue.<span class="built_in">push</span>(level<span class="number">+1</span>);      <span class="comment">//记录左孩子的层数</span></span><br><span class="line">            node_queue.<span class="built_in">push</span>(node_ptr-&gt;right);<span class="comment">//压入右孩子</span></span><br><span class="line">            level_queue.<span class="built_in">push</span>(level<span class="number">+1</span>); <span class="comment">//记录右孩子的层数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-奇偶树Ⅱ"><a href="#2-奇偶树Ⅱ" class="headerlink" title="2.奇偶树Ⅱ"></a>2.奇偶树Ⅱ</h5><p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231109112831305.png" alt="image-20231109112831305"></p>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用层序遍历</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isParityTree1</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt;node_queue; <span class="comment">//结点队列</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;level_queue; <span class="comment">//结点所在层数队列</span></span><br><span class="line">    node_queue.<span class="built_in">push</span>(head);</span><br><span class="line">    level_queue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    TreeNode* pre_node=<span class="literal">nullptr</span>; <span class="comment">//记录前一个出队的非空结点</span></span><br><span class="line">    <span class="type">int</span> pre_level=<span class="number">0</span>;<span class="comment">//记录前一个出队的非空结点层数，初始值为0</span></span><br><span class="line">    <span class="keyword">while</span>(!node_queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode* node_ptr=node_queue.<span class="built_in">front</span>();</span><br><span class="line">        node_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> level=level_queue.<span class="built_in">front</span>();</span><br><span class="line">        level_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(node_ptr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node_ptr-&gt;val%<span class="number">2</span>!=level%<span class="number">2</span>)&#123;<span class="comment">// 判断奇偶性是否相同</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pre_level==level&amp;&amp;pre_node-&gt;val&gt;=node_ptr-&gt;val)&#123;<span class="comment">//判断是否递增</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre_level=level;</span><br><span class="line">            pre_node=node_ptr;</span><br><span class="line">            node_queue.<span class="built_in">push</span>(node_ptr-&gt;left); <span class="comment">//压入左孩子</span></span><br><span class="line">            level_queue.<span class="built_in">push</span>(level<span class="number">+1</span>);      <span class="comment">//记录左孩子的层数</span></span><br><span class="line">            node_queue.<span class="built_in">push</span>(node_ptr-&gt;right);<span class="comment">//压入右孩子</span></span><br><span class="line">            level_queue.<span class="built_in">push</span>(level<span class="number">+1</span>); <span class="comment">//记录右孩子的层数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用前序遍历</span></span><br><span class="line"><span class="function">vector&lt;TreeNode*&gt; <span class="title">pre_nodes</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isParityTree2</span><span class="params">(TreeNode* head,<span class="type">int</span> level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;val%<span class="number">2</span>!=level%<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre_nodes[level]!=<span class="literal">nullptr</span>&amp;&amp;pre_nodes[level]-&gt;val&gt;=head-&gt;val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre_nodes[level]=head;<span class="comment">//记录一层最先遇到的结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isParityTree2</span>(head-&gt;left,level<span class="number">+1</span>)&amp;&amp;<span class="built_in">isParityTree2</span>(head-&gt;right,level<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的判断"><a href="#二叉树的判断" class="headerlink" title="二叉树的判断"></a>二叉树的判断</h3><h4 id="1-判断是否是搜索二叉树——中序遍历or树型dp"><a href="#1-判断是否是搜索二叉树——中序遍历or树型dp" class="headerlink" title="1.判断是否是搜索二叉树——中序遍历or树型dp"></a>1.判断是否是搜索二叉树——中序遍历or树型dp</h4><blockquote>
<p><strong>二叉搜索树</strong>又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:<br>1.若它的左子树不为空，则左子树上所有节点的值都小于根节点的值<br>2.若它的右子树不为空，则右子树上所有节点的值都大于根节点的值<br>3.它的左右子树也分别为二叉搜索树</p>
<p>即&#x3D;&#x3D;左&lt;根&lt;右&#x3D;&#x3D;</p>
<p><font color="red">搜索二叉树是不允许数据冗余的，意思就是插入相同的值只会存在一个该值</font></p>
<img src="/MyBlog/.io//3c84287ce09c442480be91ba6c589f58.png" alt="在这里插入图片描述" style="zoom:80%;">
</blockquote>
<p><strong>代码如下</strong></p>
<p>利用中序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用中序遍历(递归)进行搜索二叉树的判断</span></span><br><span class="line"><span class="type">int</span> preValue=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkBST</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> isLeftBst= <span class="built_in">checkBST</span>(head-&gt;left);<span class="comment">//判断左子树是不是搜索二叉树 </span></span><br><span class="line">    <span class="comment">//在中序遍历中，这个地方是打印行为，这里就变成处理比较行为</span></span><br><span class="line">    <span class="keyword">if</span>(!isLeftBst)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;val&lt;=preValue)&#123; <span class="comment">//如果值降序，说明不是搜索二叉树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        preValue=head-&gt;val; <span class="comment">//记录当前结点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">checkBST</span>(head-&gt;right); <span class="comment">//判断右子树是不是搜索二叉树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用中序遍历(非递归)进行搜索二叉树的判断</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkBST2</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    <span class="type">int</span>  preValue=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()||head!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="literal">nullptr</span>)&#123; <span class="comment">//一直找左孩子，直到为空</span></span><br><span class="line">            stk.<span class="built_in">push</span>(head);</span><br><span class="line">            head=head-&gt;left;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;  <span class="comment">//为空后，弹出结点，打印，然后找右孩子</span></span><br><span class="line">            head=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;val&lt;=preValue)&#123;<span class="comment">//在中序遍历中，这个地方是打印行为，这里就变成处理比较行为</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                preValue=head-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用树型dp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用树型dp（动态规划）判断搜索二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReturnData</span>&#123; <span class="comment">//定义一个返回数据类，返回三个数据，对左子树需要最大值，对右子树需要最小值，取全集</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">bool</span> isBST;</span><br><span class="line">        <span class="type">int</span> Min;</span><br><span class="line">        <span class="type">int</span> Max;</span><br><span class="line">        <span class="built_in">ReturnData</span>(<span class="type">bool</span> is,<span class="type">int</span> mi, <span class="type">int</span> ma)&#123;</span><br><span class="line">            isBST= is;</span><br><span class="line">            Min= mi;</span><br><span class="line">            Max=ma;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ReturnData* <span class="title">process1</span><span class="params">(TreeNode* x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">//必须这么返回，因为你不管怎么设最大最小都有干扰</span></span><br><span class="line">    &#125;</span><br><span class="line">    ReturnData* leftData=<span class="built_in">process1</span>(x-&gt;left); <span class="comment">//得到左子树的数据</span></span><br><span class="line">    ReturnData* rightData=<span class="built_in">process1</span>(x-&gt;right); <span class="comment">//得到右子树的数据</span></span><br><span class="line">    <span class="comment">//找x的最小，最大</span></span><br><span class="line">    <span class="type">int</span> Min=x-&gt;val;</span><br><span class="line">    <span class="type">int</span> Max=x-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(leftData!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Min=<span class="built_in">min</span>(Min,leftData-&gt;Min);</span><br><span class="line">        Max=<span class="built_in">max</span>(Max,leftData-&gt;Max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rightData!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Min=<span class="built_in">min</span>(Min,rightData-&gt;Min);</span><br><span class="line">        Max=<span class="built_in">max</span>(Max,rightData-&gt;Max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是搜索二叉树</span></span><br><span class="line">    <span class="type">bool</span> isBST=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(leftData!=<span class="literal">nullptr</span>&amp;&amp;(!leftData-&gt;isBST||leftData-&gt;Max&gt;=x-&gt;val))&#123;</span><br><span class="line">        isBST=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rightData!=<span class="literal">nullptr</span>&amp;&amp;(!rightData-&gt;isBST||rightData-&gt;Min&lt;=x-&gt;val))&#123;</span><br><span class="line">        isBST=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ReturnData</span>(isBST,Min,Max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkBST3</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process1</span>(head)-&gt;isBST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-判断是否是完全二叉树——宽度优先遍历"><a href="#2-判断是否是完全二叉树——宽度优先遍历" class="headerlink" title="2.判断是否是完全二叉树——宽度优先遍历"></a>2.判断是否是完全二叉树——宽度优先遍历</h4><blockquote>
<p>利用宽度优先遍历，根据以下两个条件判断是否是完全二叉树</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231103175658472.png" alt="image-20231103175658472"></p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用宽度优先遍历判断是否是完全二叉树</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkCBT</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="type">bool</span> leaf=<span class="literal">false</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(head);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode* cur=q.<span class="built_in">front</span>(); <span class="comment">//一层一层弹出</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//两个条件，1.对任一结点，有右无左 false，2.在1不成立条件下，如果遇到第一个左右子结点不全，后续都是叶节点</span></span><br><span class="line">        <span class="keyword">if</span>((cur-&gt;left==<span class="literal">nullptr</span>&amp;&amp;cur-&gt;right!=<span class="literal">nullptr</span>)||(leaf&amp;&amp;(cur-&gt;left!=<span class="literal">nullptr</span>||cur-&gt;right!=<span class="literal">nullptr</span>)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left!=<span class="literal">nullptr</span>)&#123; <span class="comment">//先进左结点，先出</span></span><br><span class="line">            q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right!=<span class="literal">nullptr</span>)&#123;<span class="comment">//先进右结点，后出</span></span><br><span class="line">            q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left==<span class="literal">nullptr</span>||cur-&gt;right==<span class="literal">nullptr</span>)&#123; <span class="comment">//判断是否是叶结点</span></span><br><span class="line">            leaf=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-判断是否是满二叉树"><a href="#3-判断是否是满二叉树" class="headerlink" title="3.判断是否是满二叉树"></a>3.判断是否是满二叉树</h4><blockquote>
<p>判断是否是满二叉树只需要满足一个条件：</p>
<p>深度为k的二叉树结点总数为$$2^k-1。(k\ge 1)$$</p>
<p>故可以遍历找深度和结点数</p>
<p>也可用树型dp</p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否是满二叉树,用性质结点数=2^深度-1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&#123;  <span class="comment">//返回数据类型，返回两数据</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> height; <span class="comment">//深度</span></span><br><span class="line">        <span class="type">int</span> nodes; <span class="comment">//结点数</span></span><br><span class="line">        <span class="built_in">Info</span>(<span class="type">int</span> h,<span class="type">int</span> n)&#123;</span><br><span class="line">            height=h;</span><br><span class="line">            nodes=n;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Info <span class="title">process3</span><span class="params">(TreeNode *x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Info</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Info leftData=<span class="built_in">process3</span>(x-&gt;left); </span><br><span class="line">    Info rightData=<span class="built_in">process3</span>(x-&gt;right);</span><br><span class="line">    <span class="type">int</span> height=<span class="built_in">max</span>(leftData.height,rightData.height)<span class="number">+1</span>; <span class="comment">//计算当前节点的高度</span></span><br><span class="line">    <span class="type">int</span> nodes=leftData.nodes+rightData.nodes<span class="number">+1</span>; <span class="comment">//计算当前节点的所有结点数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Info</span>(height,nodes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkFull</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return pow(2,process3(head).height)-1==process3(head).nodes?true:false;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process3</span>(head).nodes==((<span class="number">1</span>&lt;&lt;<span class="built_in">process3</span>(head).height)<span class="number">-1</span>)?<span class="literal">true</span>:<span class="literal">false</span>; <span class="comment">//用位运算计算次方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-判断是否是平衡二叉树——利用树型dp求解"><a href="#4-判断是否是平衡二叉树——利用树型dp求解" class="headerlink" title="4.判断是否是平衡二叉树——利用树型dp求解"></a>4.判断是否是平衡二叉树——利用树型dp求解</h4><blockquote>
<p>判断「平衡二叉树」的 2 个条件：</p>
<ul>
<li><p><strong>1. 是「二叉排序树」(二叉搜索树)</strong></p>
</li>
<li><p><strong>2. 任何一个节点的左子树或者右子树都是「平衡二叉树」（左右高度差小于等于 1）</strong></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231106105641638.png" alt="image-20231106105641638"></p>
</li>
</ul>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用树型dp判断是否是平衡二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReturnType</span>&#123; <span class="comment">//设置两个返回数据</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">bool</span> isBalanced;</span><br><span class="line">        <span class="type">int</span> height;</span><br><span class="line">        <span class="built_in">ReturnType</span>(<span class="type">bool</span> isB,<span class="type">int</span> hei)&#123;</span><br><span class="line">            isBalanced=isB;</span><br><span class="line">            height=hei;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ReturnType <span class="title">process</span><span class="params">(TreeNode* x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="literal">nullptr</span>)&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ReturnType</span>(<span class="literal">true</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReturnType leftData=<span class="built_in">process</span>(x-&gt;left); <span class="comment">//通过递归得到左树的数据</span></span><br><span class="line">    ReturnType rightData=<span class="built_in">process</span>(x-&gt;right);<span class="comment">//得到右数的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> height=<span class="built_in">max</span>(leftData.height,rightData.height)<span class="number">+1</span>; <span class="comment">//获取高度信息</span></span><br><span class="line">    <span class="comment">//获取是否是平衡二叉树的信息</span></span><br><span class="line">    <span class="type">bool</span> isBalanced=leftData.isBalanced&amp;&amp;rightData.isBalanced&amp;&amp;<span class="built_in">abs</span>(leftData.height-rightData.height)&lt;<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">ReturnType</span>(isBalanced,height);<span class="comment">//返回两信息，x是否是平衡树</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkBalanced</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(head).isBalanced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、最优二叉树（哈夫曼树）"><a href="#四、最优二叉树（哈夫曼树）" class="headerlink" title="四、最优二叉树（哈夫曼树）"></a>四、最优二叉树（哈夫曼树）</h3><p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231113113435150.png" alt="image-20231113113435150"></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231113113546663.png" alt="image-20231113113546663"></p>
<h4 id="最优二叉树的性质"><a href="#最优二叉树的性质" class="headerlink" title="最优二叉树的性质"></a>最优二叉树的性质</h4><p><strong>1.最优二叉树是满二叉树</strong></p>
<p><strong>2.最优二叉树中，如果两个叶结点的权重值不同，则权重值小的叶结点在<br>树中的层数大于等于权重值大的叶结点</strong></p>
<p><strong>3.若有n个结点，则在哈夫曼树的构造过程中，新建了n-1个结点，最终所得到的&#x3D;&#x3D;结点总数为2n-1&#x3D;&#x3D;</strong></p>
<p><strong>4.给定一组叶结点权重，存在最优二叉树，&#x3D;&#x3D;权重最小和次小&#x3D;&#x3D;的叶结点在树<br>的最下层并且互为兄弟结点</strong></p>
<p><strong>5.由于哈夫曼树只有度为0和2的结点，不存在度为1的结点，即n&#x3D;n0+n2，且又由二叉树的性质，叶子结点数等于度为2的结点数加1（&#x3D;&#x3D;n0&#x3D;n2+1&#x3D;&#x3D;），故从而可以求得哈夫曼树的叶子结点数和度为2的结点数。</strong></p>
<h3 id="二叉树的一些题"><a href="#二叉树的一些题" class="headerlink" title="二叉树的一些题"></a>二叉树的一些题</h3><h4 id="1-给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点"><a href="#1-给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点" class="headerlink" title="1.给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点"></a>1.给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点</h4><blockquote>
<p><strong>通过两种情况来分析</strong></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231107105817990.png" alt="image-20231107105817990"></p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最优解，分为两种情况，一种o1或o2是公共父结点，一种都不是要找相交</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor2</span><span class="params">(TreeNode* head,TreeNode* o1,TreeNode* o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head==o1||head==o2)&#123;<span class="comment">// 当遇到空或o1或o2返回</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* left=<span class="built_in">lowestCommonAncestor2</span>(head-&gt;left,o1,o2); <span class="comment">//从左子树获取信息，为空，o1,o2</span></span><br><span class="line">    TreeNode* right=<span class="built_in">lowestCommonAncestor2</span>(head-&gt;right,o1,o2);<span class="comment">//从右子树获取信息，为空，o1,o2</span></span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="literal">nullptr</span>&amp;&amp;right!=<span class="literal">nullptr</span>)&#123; <span class="comment">//当左或右都不为空，说明是第二种情况，那么此时的结点就是公共结点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left!=<span class="literal">nullptr</span>?left:right;<span class="comment">//当左或右有一个不为空，返回不空的，都为空，返回空。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-在二叉树中找到一个节点的后继节点"><a href="#2-在二叉树中找到一个节点的后继节点" class="headerlink" title="2.在二叉树中找到一个节点的后继节点"></a>2.在二叉树中找到一个节点的后继节点</h4><p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231107111708733.png" alt="image-20231107111708733"></p>
<blockquote>
<p>后继节点就是中序遍历序列中的下一个节点</p>
</blockquote>
<h4 id="3-表达式树"><a href="#3-表达式树" class="headerlink" title="3.表达式树"></a>3.表达式树</h4><h4 id="4-二叉树的序列化和反序列化"><a href="#4-二叉树的序列化和反序列化" class="headerlink" title="4.二叉树的序列化和反序列化"></a>4.二叉树的序列化和反序列化</h4><p><strong>1.前序遍历方法</strong></p>
<blockquote>
<ul>
<li>序列化的时候被分成三部分（左 -&gt; 右）：根节点、左子树、右子树</li>
<li>因此反序列化用队列</li>
<li><strong>（一般来说，还原二叉树需要前序+中序&#x2F;后序+中序，由于node包含所有节点的信息，包括空指针的信息，因此可以直接还原）</strong></li>
</ul>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    serialize(root, sb);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历位置</span></span><br><span class="line">    sb.append(<span class="string">&quot;&quot;</span> + root.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">    serialize(root.left, sb);</span><br><span class="line">    serialize(root.right, sb);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String node : data.split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">        nodes.offer(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历位置</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">node</span> <span class="operator">=</span> nodes.poll();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;null&quot;</span>.equals(node)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(node));</span><br><span class="line"></span><br><span class="line">    root.left = deserialize(nodes);</span><br><span class="line">    root.right = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2.后序遍历方法</strong></p>
<blockquote>
<ul>
<li>后序遍历的序列化时候，只需把append放到后序遍历的位置去，因此序列化的顺序也改变了</li>
<li>被分成三部分（左 -&gt; 右）：左子树、右子树、根节点</li>
<li>因此反序列化用栈</li>
<li>反序列化的时候，我们还是要先获取根节点，<strong>然后是右子树</strong>、最后才是左子树</li>
</ul>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    serialize(root, sb);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serialize(root.left, sb);</span><br><span class="line">    serialize(root.right, sb);        </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历位置</span></span><br><span class="line">    sb.append(<span class="string">&quot;&quot;</span> + root.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String node : data.split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">        nodes.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历位置</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">node</span> <span class="operator">=</span> nodes.pop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;null&quot;</span>.equals(node)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(node));</span><br><span class="line"></span><br><span class="line">    root.right = deserialize(nodes);</span><br><span class="line">    root.left = deserialize(nodes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3.中序遍历方法</strong></p>
<blockquote>
<ul>
<li>我们不能通过中序遍历将字符串反序列化成一颗二叉树，前序遍历根节点在第一个，后序遍历根节点在最后一个，二中序遍历根节点在中间</li>
<li>但是可以进行序列化</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serialize(root.left, sb);</span><br><span class="line">    <span class="comment">// 中序遍历位置</span></span><br><span class="line">    sb.append(<span class="string">&quot;&quot;</span> + root.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    serialize(root.right, sb);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.层序遍历方法：</strong></p>
<blockquote>
<ul>
<li>序列化同样按照层序遍历，利用队列遍历每一层节点，然后序列化到字符串中去</li>
<li>反序列化的时候同样也是用队列进行层序遍历的，因为空指针也被记录进去，所以要用<code>i</code>记录子节点的位置，不管子节点是不是空的，都要先获取判断一下</li>
</ul>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">&quot;&quot;</span> + node.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">        queue.offer(node.left);</span><br><span class="line">        queue.offer(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(data) || data.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] nodes = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(nodes[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nodes.length;) &#123;</span><br><span class="line">        <span class="comment">// 先出队，获取节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span>  queue.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">left</span> <span class="operator">=</span> nodes[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;null&quot;</span>.equals(left)) &#123;</span><br><span class="line">            node.left = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(left));</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右子树</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">right</span> <span class="operator">=</span> nodes[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;null&quot;</span>.equals(right)) &#123;</span><br><span class="line">            node.right = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(right));</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="5-折纸问题"><a href="#5-折纸问题" class="headerlink" title="5.折纸问题"></a>5.折纸问题</h4><p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231114152109686.png" alt="image-20231114152109686"></p>
<h3 id="二叉树拓展"><a href="#二叉树拓展" class="headerlink" title="二叉树拓展"></a>二叉树拓展</h3><h4 id="1-树的存储方式"><a href="#1-树的存储方式" class="headerlink" title="1.树的存储方式"></a>1.树的存储方式</h4><p>与二叉树相似，树也有<strong>顺序存储</strong>与 <strong>链接存储</strong>两种方式，而选择何种方式与在树结<br>点中记录哪些表示树逻辑结构的信息相关<br>常用的树逻辑结构表示法：<strong>父亲表示法</strong> 、 <strong>孩子表示法</strong>以及<strong>孩子兄弟表示法</strong></p>
<h5 id="父亲表示法"><a href="#父亲表示法" class="headerlink" title="父亲表示法"></a>父亲表示法</h5><h4 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h4><p>&#x3D;&#x3D;实现生成前缀树，包括添加、删除、查找的功能，此外还需要查找某个前缀出现的次数&#x3D;&#x3D;</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231123085132007.png" alt="image-20231123085132007"></p>
<blockquote>
<p>前缀树用于统计词频，如下图当我们添加&#x3D;&#x3D;“abc”，“bck”,“abd”,“ace”&#x3D;&#x3D;时就会得到如下树。其中根节点不存储字符，只起标记位置作用，为了存储26个字母，每个节点有26条隐含的路可分别存储a-z的字符，添加上节点时，路才显示为存储的字符，那么可以看出这种树和一般的树不同，最多每个节点有26个子节点；</p>
<p>如果像存储“abc”,“abd”这样，不同字符串的相同位置“ab”相同时，使用同一个节点。<br><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231123085151737.png" alt="image-20231123085151737"></p>
</blockquote>
<blockquote>
<p>为了增加前缀树的功能，我们在节点上增加了两个变量pass和end初始化为0。pass是这个节点经过了几次，end是以这个节点结束有几次。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231123085539972.png" alt="image-20231123085539972"></p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> num 26</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> pass; <span class="comment">//经过的次数</span></span><br><span class="line">        <span class="type">int</span> end; <span class="comment">//结尾的次数</span></span><br><span class="line">        TrieNode* nexts[num]; <span class="comment">//设置字符串个数的最多前缀‘a~z’</span></span><br><span class="line">        <span class="comment">//如果字符特别多，用数组浪费空间：</span></span><br><span class="line">        <span class="comment">//也可以用哈希表unordered_map&lt;char,TrieNode&gt; nexts; char记录路，TrieNode表示路的下一个节点</span></span><br><span class="line">        <span class="comment">//TreeMap&lt;&gt; nexts;</span></span><br><span class="line">        <span class="built_in">TrieNode</span>():<span class="built_in">pass</span>(<span class="number">0</span>),<span class="built_in">end</span>(<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//memset 函数用于设置nexts数组的初始值为0</span></span><br><span class="line">            <span class="built_in">memset</span>(nexts,<span class="number">0</span>,<span class="built_in">sizeof</span>(nexts)); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrieTree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        TrieNode *root;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">TrieTree</span>();</span><br><span class="line">        ~<span class="built_in">TrieTree</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(TrieNode *node)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(string word)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">delete_word</span><span class="params">(string word)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">prefixNumber</span><span class="params">(string pre)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">TrieTree::<span class="built_in">TrieTree</span>()&#123;</span><br><span class="line">    root=<span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">TrieTree::~<span class="built_in">TrieTree</span>()&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除整棵树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieTree::destroy</span><span class="params">(TrieNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root ==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">	&#123;	<span class="comment">//每个new出的数组需要删除</span></span><br><span class="line">		<span class="built_in">destroy</span>(root-&gt;nexts[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> root;</span><br><span class="line">	root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieTree::insert</span><span class="params">(string word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(&amp;word==<span class="literal">NULL</span>)	<span class="comment">//不能用word.empty()来写，不然不能加入“”的字符串							</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(word.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		root-&gt;pass++;</span><br><span class="line">	&#125;</span><br><span class="line">	TrieNode *node = root;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; word.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		index = word[i] - <span class="string">&#x27;a&#x27;</span>;					<span class="comment">//将输入的字符转换为索引值a是0，b是1...</span></span><br><span class="line">		<span class="keyword">if</span>(node-&gt;nexts[index] == <span class="literal">NULL</span>)			<span class="comment">//这条路未被创建</span></span><br><span class="line">		&#123;</span><br><span class="line">			node-&gt;nexts[index] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();<span class="comment">//创建路</span></span><br><span class="line">		&#125;</span><br><span class="line">		node = node-&gt;nexts[index];				<span class="comment">//指向新建的路</span></span><br><span class="line">		node-&gt;pass++;							<span class="comment">//经过+1</span></span><br><span class="line">	&#125;</span><br><span class="line">	node-&gt;end++;								<span class="comment">//最后再记录结束</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TrieTree::search</span><span class="params">(string word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(&amp;word==<span class="literal">NULL</span>) <span class="comment">//不能用word.empty()来写，不然不能加入“”的字符串</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	TrieNode *node = root;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; word.<span class="built_in">size</span>();i++) <span class="comment">//遍历这个字符串</span></span><br><span class="line">	&#123;</span><br><span class="line">		index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(node-&gt;nexts[index]==<span class="literal">NULL</span>) <span class="comment">//如果没有这条路则换回0</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		node = node-&gt;nexts[index];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node-&gt;end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TrieTree::delete_word</span><span class="params">(string word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">search</span>(word) == <span class="number">0</span>)		<span class="comment">//先进行查找确定存在</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	TrieNode *node = root;</span><br><span class="line">	TrieNode *tmp = root;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; word.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		index = word[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		tmp = node-&gt;nexts[index];			<span class="comment">//使用中间变量记录当前节点的下一个节点</span></span><br><span class="line">		<span class="keyword">if</span>(--node-&gt;nexts[index]-&gt;pass == <span class="number">0</span>)&#123;	<span class="comment">//如果将--pass后，节点的pass为0，表示以后的节点都不存在</span></span><br><span class="line">			<span class="built_in">destroy</span>(tmp);</span><br><span class="line">			node-&gt;nexts[index]=<span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">break</span>;		<span class="comment">//释放</span></span><br><span class="line">        &#125;   </span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">            node = tmp;							<span class="comment">//当前节点移动到下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	node-&gt;end--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TrieTree::prefixNumber</span><span class="params">(string pre)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pre==<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> root-&gt;pass;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(&amp;pre==<span class="literal">NULL</span>) <span class="comment">//不能用pre.empty()来写，不然不能加入“”的字符串</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	TrieNode* node = root;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; pre.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		index = pre[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(node-&gt;nexts[index] == <span class="literal">NULL</span>)	<span class="comment">//不存在此前缀直接返回0个</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		node = node-&gt;nexts[index];		</span><br><span class="line">	&#125;	<span class="keyword">return</span> node-&gt;pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="六、图"><a href="#六、图" class="headerlink" title="六、图"></a>六、图</h2><p><font size="4"><strong>【知识框架】</strong></font></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231207112738087.png" alt="image-20231207112738087"></p>
<h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><p>在<strong>线性表</strong>中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继。</p>
<p>在<strong>树形结构</strong>中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关。</p>
<p>图是一种较线性表和树更加复杂的数据结构。在<strong>图形结构</strong>中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。</p>
<h3 id="一、图的定义"><a href="#一、图的定义" class="headerlink" title="一、图的定义"></a>一、图的定义</h3><p><strong>图（Graph）是由顶点的有穷非空集合$V(G)$和顶点之间边的集合$E(G)$组成，</strong>通常表示为:$G&#x3D;(V,E)$，其中G表示个图，V是图G中顶点的集合，E是图G中边的集合。<strong>若$V&#x3D;{v_1,v_2,\cdots ,v_n}$则用$|V|$表示图中G中顶点的个数，也称图G的阶，$E&#x3D;{(u,v)|u\in U,v\in V}$,用$|E|$表示图中G中边的条数。</strong></p>
<blockquote>
<p>注意:线性表可以是空表，树可以是空树，&#x3D;&#x3D;但图不可以是空图。&#x3D;&#x3D;就是说，图中不能一个顶点也没有，图的顶点集V一定非空，但边集E可以为空，此时图中只有顶点而没有边。</p>
</blockquote>
<h3 id="二、图的基本概念和术语"><a href="#二、图的基本概念和术语" class="headerlink" title="二、图的基本概念和术语"></a>二、图的基本概念和术语</h3><h4 id="1、有向图"><a href="#1、有向图" class="headerlink" title="1、有向图"></a>1、有向图</h4><p>若E是有向边(也称弧)的有限集合时，则图G为有向图。弧是顶点的有序对，记为&lt;v, w&gt;，其中v,w是顶点，v称为弧尾，w称为弧头，&lt;v,w&gt;称为从顶点v到顶点w的弧，也称v邻接到w，或w邻接自v。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210227111745661.png" alt="在这里插入图片描述"></p>
<p>图(a)所示的有向图$G_1$可表示为<br>$$<br>G_1&#x3D;(V_1,E_1)\<br>V_1&#x3D;{1,2,3}\<br>E_1&#x3D;{&lt;1,2&gt;,&lt;2,1&gt;,&lt;2,3&gt;}<br>$$</p>
<h4 id="2、无向图"><a href="#2、无向图" class="headerlink" title="2、无向图"></a>2、无向图</h4><p>若E是无向边(简称边)的有限集合时，则图G为无向图。边是顶点的无序对，记为(v, w)或(w,v),因为(v,w)&#x3D;(w,v), 其中v,w是顶点。可以说顶点w和顶点v互为邻接点。边(v, w)依附于顶点w和v，或者说边(v, w)和顶点v, w相关联。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210227112230368.png" alt="在这里插入图片描述"></p>
<p><a target="_blank" rel="noopener" href="http://t.csdnimg.cn/rVrJt">其他有关概念</a></p>
<h3 id="三、图的存储结构"><a href="#三、图的存储结构" class="headerlink" title="三、图的存储结构"></a>三、图的存储结构</h3><h4 id="一、邻接矩阵"><a href="#一、邻接矩阵" class="headerlink" title="一、邻接矩阵"></a>一、邻接矩阵</h4><p><strong>图的邻接矩阵(Adjacency Matrix) 存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。</strong></p>
<img src="/MyBlog/.io//image-20231219155105178.png" alt="image-20231219155105178" style="zoom:150%;">

<p>下图是一个无向图和其邻接矩阵：</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/202103011006555.png" alt="202103011006555"></p>
<p>下图是有向图和它的邻接矩阵：</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70-17028707596763.png" alt="在这里插入图片描述"></p>
<img src="/MyBlog/.io//image-20231219155142253.png" alt="image-20231219155142253" style="zoom: 150%;">

<h4 id="二、邻接表"><a href="#二、邻接表" class="headerlink" title="二、邻接表"></a>二、邻接表</h4><p>**邻接表是指对图G中的每个顶点$v_i$建立一个单链表，第i个单链表中的结点表示依附于顶点$v_i$的边(对于有向图则是以顶点$v_i$为尾的弧)，这个单链表就称为顶点$v_i$的边表(对于有向图则称为出边表)**。边表的头指针和顶点的数据信息采用顺序存储(称为顶点表)，所以在邻接表中存在两种结点:顶点表结点和边表结点，如下图所示。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210301165106350.png" alt="在这里插入图片描述"></p>
<p>顶点表结点由顶点域(data)和指向第一条邻接边的指针(firstarc) 构成，边表(邻接表)结点由邻接点域(adjvex)和指向下一条邻接边的指针域(nextarc) 构成。<br>无向图的邻接表的实例如下图所示。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>有向图的邻接表的实例如下图所示。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70-17030595963935.png" alt="在这里插入图片描述"></p>
<h4 id="三、十字链表"><a href="#三、十字链表" class="headerlink" title="三、十字链表"></a>三、十字链表</h4><h4 id="四、邻接多重表"><a href="#四、邻接多重表" class="headerlink" title="四、邻接多重表"></a>四、邻接多重表</h4><h4 id="五、边集数组"><a href="#五、边集数组" class="headerlink" title="五、边集数组"></a>五、边集数组</h4><h4 id="六、存储模板"><a href="#六、存储模板" class="headerlink" title="六、存储模板"></a>六、存储模板</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> in;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> out;</span><br><span class="line">	<span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;</span><br><span class="line">	<span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.value=value;</span><br><span class="line">		in=<span class="number">0</span>;</span><br><span class="line">		out=<span class="number">0</span>;</span><br><span class="line">		nexts=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		edges=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> Node from;</span><br><span class="line">    <span class="keyword">public</span> Node to;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> weight,Node from,Node to)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.weight=weight;</span><br><span class="line">        <span class="built_in">this</span>.from=from;</span><br><span class="line">        <span class="built_in">this</span>.to=to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer,Node&gt; nodes;</span><br><span class="line">    <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line">   	<span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">()</span>&#123;</span><br><span class="line">        nodes=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        edges=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Graph <span class="title function_">createGraph</span><span class="params">()</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>;</span><br><span class="line"><span class="comment">//节点的五个数据，值，入度，出度，下一节点，该节点出发的边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="type">int</span> in;</span><br><span class="line">        <span class="type">int</span> out;</span><br><span class="line">        list&lt;Node*&gt; nexts;</span><br><span class="line">        list&lt;Edge*&gt; edges;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> value)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;value=value;</span><br><span class="line">            in=<span class="number">0</span>;</span><br><span class="line">            out=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Graph类有点和边两大部分，使用hash_map存储节点,使用hash_set存储边的信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,Node*&gt; nodes;</span><br><span class="line">        unordered_set&lt;Edge*&gt; edges;</span><br><span class="line">        <span class="built_in">Graph</span>()&#123;&#125;;</span><br><span class="line">        <span class="built_in">Graph</span>(Node* node,Edge* edge)&#123;</span><br><span class="line">            nodes.<span class="built_in">emplace</span>(<span class="number">1</span>,node);</span><br><span class="line">            edges.<span class="built_in">emplace</span>(edge);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边上的权重、当前边的from和to节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        Node* from;</span><br><span class="line">        Node* to;</span><br><span class="line">        <span class="built_in">Edge</span>(<span class="type">int</span> weight,Node* from,Node* to)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;weight=weight;</span><br><span class="line">            <span class="keyword">this</span>-&gt;from=from;</span><br><span class="line">            <span class="keyword">this</span>-&gt;to=to;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Graph <span class="title">createGraph</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix)</span></span>&#123;</span><br><span class="line">    Graph graph;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> weight=matrix[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> from = matrix[i][<span class="number">1</span>];</span><br><span class="line">		<span class="type">int</span> to = matrix[i][<span class="number">2</span>];</span><br><span class="line">		<span class="comment">//Graph的node里不含有from节点、to节点时建上 </span></span><br><span class="line">		<span class="keyword">if</span>(graph.nodes.<span class="built_in">find</span>(from) == graph.nodes.<span class="built_in">end</span>())</span><br><span class="line">			graph.nodes[from] = <span class="keyword">new</span> <span class="built_in">Node</span>(from);</span><br><span class="line">		<span class="keyword">if</span>(graph.nodes.<span class="built_in">find</span>(to) == graph.nodes.<span class="built_in">end</span>())</span><br><span class="line">			graph.nodes[to] = <span class="keyword">new</span> <span class="built_in">Node</span>(to);</span><br><span class="line">		<span class="comment">//拿出from，to点</span></span><br><span class="line">		Node* fromNode = graph.nodes[from];		</span><br><span class="line">		Node* toNode = graph.nodes[to];</span><br><span class="line">		<span class="comment">//Node* fromNode = graph.nodes.find(from)-&gt;second;		</span></span><br><span class="line">		<span class="comment">//Node* toNode = graph.nodes.find(to)-&gt;second;</span></span><br><span class="line">		<span class="comment">//新建边 </span></span><br><span class="line">		Edge* newEdge = <span class="keyword">new</span> <span class="built_in">Edge</span>(weight, fromNode, toNode);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//增加节点的四个数据 </span></span><br><span class="line">		fromNode-&gt;nexts.<span class="built_in">push_back</span>(toNode);</span><br><span class="line">		fromNode-&gt;edges.<span class="built_in">push_back</span>(newEdge);</span><br><span class="line">		fromNode-&gt;out++;</span><br><span class="line">		toNode-&gt;in++;</span><br><span class="line">		graph.edges.<span class="built_in">insert</span>(newEdge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; matrix= &#123;&#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">	Graph graph = <span class="built_in">createGraph</span>(matrix);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test </span></span><br><span class="line">	unordered_map&lt;<span class="type">int</span>,Node*&gt;::iterator ite1 = graph.nodes.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span>(ite1 != graph.nodes.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">	 	cout &lt;&lt; <span class="string">&quot;节点: &quot;</span>&lt;&lt;(ite1)-&gt;second-&gt;value&lt;&lt;<span class="string">&quot;、&quot;</span>;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;节点: &quot;&lt;&lt;(ite1)-&gt;first&lt;&lt;&quot;、&quot;;</span></span><br><span class="line">	 	ite1++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;-----------------------------------------------&quot;</span>&lt;&lt;endl ;</span><br><span class="line">	unordered_set&lt;Edge*&gt;::iterator ite = graph.edges.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span>(ite != graph.edges.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">	 	cout &lt;&lt; <span class="string">&quot;边权为 &quot;</span>&lt;&lt;(*ite)-&gt;weight&lt;&lt;<span class="string">&quot;    &quot;</span>;</span><br><span class="line">	 	cout&lt;&lt;(*ite)-&gt;from-&gt;value &lt;&lt;<span class="string">&quot;----&gt;&quot;</span>&lt;&lt;(*ite)-&gt;to-&gt;value&lt;&lt;endl; </span><br><span class="line">	 	ite++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;-----------------------------------------------&quot;</span>&lt;&lt;endl ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="四、图的遍历"><a href="#四、图的遍历" class="headerlink" title="四、图的遍历"></a>四、图的遍历</h3><h4 id="1-宽度优先遍历"><a href="#1-宽度优先遍历" class="headerlink" title="1.宽度优先遍历"></a>1.宽度优先遍历</h4><p><strong>图的广度优先遍历类似于树的层序遍历。</strong></p>
<blockquote>
<p>&#x3D;&#x3D;广度优先遍历是一种分层的查找过程&#x3D;&#x3D;，每向前走一步可能访问一批顶点，不像深度优先遍历那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，&#x3D;&#x3D;算法必须借助一个辅助队列&#x3D;&#x3D;，以记忆正在访问的顶点的下一层顶点。</p>
<p><strong>步骤如下：</strong></p>
<p>①利用队列实现 ；<br>②从源节点开始依次按照宽度进队列，然后弹出 ；<br>③每弹出一个点，把该节点所有没有进过队列的邻接点放入队列；<br>④直到队列变空；</p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宽度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(Node* nodes)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nodes==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;Node*&gt; q; <span class="comment">//用队列来遍历</span></span><br><span class="line">    unordered_set&lt;Node*&gt; set;<span class="comment">//用集合辅助队列，防止重复</span></span><br><span class="line">    q.<span class="built_in">push</span>(nodes);</span><br><span class="line">    set.<span class="built_in">emplace</span>(nodes);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        Node* help=q.<span class="built_in">front</span>(); <span class="comment">//弹出队列</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cout&lt;&lt;help-&gt;value&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node* t:help-&gt;nexts)&#123; <span class="comment">//遍历当前节点的邻接节点</span></span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">find</span>(t)==set.<span class="built_in">end</span>())&#123; <span class="comment">//如果不在哈希表，则入队并记录</span></span><br><span class="line">                q.<span class="built_in">push</span>(t);</span><br><span class="line">                set.<span class="built_in">emplace</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BFS算法性能分析</strong></p>
<blockquote>
<p>无论是邻接表还是邻接矩阵的存储方式，BFS 算法都需要借助一个辅助队列Q, n个顶点均需入队一次，在最坏的情况下，&#x3D;&#x3D;空间复杂度为$O(V)$&#x3D;&#x3D;。</p>
<p>采用&#x3D;&#x3D;邻接表存储&#x3D;&#x3D;方式时，每个顶点均需搜索一次(或入队一次)， 在搜索任一顶点的邻接点时，每条边至少访问一次，算法总的&#x3D;&#x3D;时间复杂度为$O(V+E)$&#x3D;&#x3D;。</p>
<p>采用&#x3D;&#x3D;邻接矩阵存储&#x3D;&#x3D;方式时，查找每个顶点的邻接点所需的时间为$O(V)$,故算法总的&#x3D;&#x3D;时间复杂度$O(V^2)$&#x3D;&#x3D;</p>
</blockquote>
<h4 id="2-深度优先遍历"><a href="#2-深度优先遍历" class="headerlink" title="2.深度优先遍历"></a>2.深度优先遍历</h4><p><strong>深度优先搜索类似于树的先序遍历。</strong></p>
<blockquote>
<p>如其名称中所暗含的意思一样，这种搜索算法所遵循的搜索策略是&#x3D;&#x3D;尽可能“深”地搜索一个图&#x3D;&#x3D;。它的基本思想如下:首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点$w_1$，再访问与$w_1$邻接且未被访问的任一顶点…重复上述过程。&#x3D;&#x3D;当不能再继续向下访问时，依次退回到最近被访问的顶点&#x3D;&#x3D;，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。</p>
<p><strong>步骤如下：</strong></p>
<p>①利用栈实现 ；<br>②从源节点开始把节点按照深度放入栈，然后弹出 ；<br>③每弹出一个点，若该节点有没有进过栈的邻接点存在，把该节点和没有进过栈的<strong>一个</strong>邻接点放入栈 ；<br>④直到栈变空；</p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历 利用栈（可以用递归）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node == <span class="literal">NULL</span>)	<span class="keyword">return</span>;</span><br><span class="line">	stack&lt;Node*&gt; s;</span><br><span class="line">	unordered_set&lt;Node*&gt; set;</span><br><span class="line">	s.<span class="built_in">push</span>(node); </span><br><span class="line">	set.<span class="built_in">insert</span>(node);</span><br><span class="line">	cout&lt;&lt;node-&gt;value&lt;&lt;<span class="string">&quot; &quot;</span>; 				<span class="comment">//第一个元素直接输出 </span></span><br><span class="line">	<span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		Node* help = s.<span class="built_in">top</span>();</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> tmp : help-&gt;nexts)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(set.<span class="built_in">find</span>(tmp) == set.<span class="built_in">end</span>())	<span class="comment">//该节点如果没有遍历过</span></span><br><span class="line">			&#123;</span><br><span class="line">				s.<span class="built_in">push</span>(help);				<span class="comment">//把当前节点压回栈</span></span><br><span class="line">				s.<span class="built_in">push</span>(tmp);				<span class="comment">//把第一个找到的邻接节点压入栈，并记录</span></span><br><span class="line">				set.<span class="built_in">insert</span>(tmp);</span><br><span class="line">				cout&lt;&lt;tmp-&gt;value&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;						<span class="comment">//一次只找一个 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p><strong>DFS算法性能分析</strong></p>
<blockquote>
<p>DFS算法是一个递归算法，需要借助一个递归工作栈，故其空间复杂度为$O(V)$</p>
<p>对于n个顶点e条边的图来说，邻接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此都需要$O(V^2)$时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量，所以是$O(V+E)$，显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。</p>
<p>对于有向图而言，由于它只是对通道存在可行或不可行，算法上没有变化，是完全可以通用的</p>
</blockquote>
<h3 id="五、拓扑排序"><a href="#五、拓扑排序" class="headerlink" title="五、拓扑排序"></a>五、拓扑排序</h3><p>适用范围：要求&#x3D;&#x3D;有向图，且有入度为0的节点（则也有出度为0的节点），且没有环&#x3D;&#x3D;</p>
<p><strong>操作：</strong>从入度为0的点出发，去掉这个点并去掉它的边，将它排到第一个，则会出现新的入度为0的点，将它和它的边去掉，并排到后面，如图</p>
<img src="/MyBlog/.io//image-20231220165617003.png" alt="image-20231220165617003" style="zoom: 50%;">

<img src="/MyBlog/.io//image-20231220165629922.png" alt="image-20231220165629922" style="zoom:50%;">

<img src="/MyBlog/.io//image-20231220165701737.png" alt="image-20231220165701737" style="zoom:50%;">



<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="function">list&lt;Node*&gt; <span class="title">sortedTopology</span><span class="params">(Graph graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	unordered_map&lt;Node*,<span class="type">int</span>&gt; inMap;			<span class="comment">//存储节点与入度 </span></span><br><span class="line">	queue&lt;Node*&gt; zeroInQueue;				<span class="comment">//存储入度为零的节点 </span></span><br><span class="line">	unordered_map&lt;<span class="type">int</span>,Node*&gt;::iterator ite = graph.nodes.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="comment">//遍历图中的所有节点，把所有入度为零的节点放入队列 </span></span><br><span class="line">	<span class="keyword">while</span>(ite != graph.nodes.<span class="built_in">end</span>())								</span><br><span class="line">	&#123;</span><br><span class="line">		inMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;Node*,<span class="type">int</span>&gt;(ite-&gt;second,ite-&gt;second-&gt;in));</span><br><span class="line">		<span class="keyword">if</span>(ite-&gt;second-&gt;in == <span class="number">0</span>)</span><br><span class="line">			zeroInQueue.<span class="built_in">push</span>(ite-&gt;second);</span><br><span class="line">		ite++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//输出入度为零的节点</span></span><br><span class="line">	<span class="comment">//把入度为零的节点所指向的节点的入度减一（相当于删去当前节点）并没有实际删除该节点</span></span><br><span class="line">	<span class="comment">//若又有入度为零的节点加入队列</span></span><br><span class="line">	list&lt;Node*&gt; result;</span><br><span class="line">	<span class="keyword">while</span>(!zeroInQueue.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		Node* help = zeroInQueue.<span class="built_in">front</span>();</span><br><span class="line">		zeroInQueue.<span class="built_in">pop</span>();</span><br><span class="line">		result.<span class="built_in">push_back</span>(help);</span><br><span class="line">		cout&lt;&lt;help-&gt;value&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(Node* t : help-&gt;nexts)			 </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(--inMap.<span class="built_in">find</span>(t)-&gt;second == <span class="number">0</span>)    <span class="comment">//去掉这个入度为0的点后又有入度为零的节点加入队列</span></span><br><span class="line">				zeroInQueue.<span class="built_in">push</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>拓扑排序实例</strong></p>
<h3 id="六、最小生成树"><a href="#六、最小生成树" class="headerlink" title="六、最小生成树"></a>六、最小生成树</h3><p><font color="red">注意：P算法和K算法都是针对无向图的算法，主要都是考虑形不形成环</font></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231222151424158.png" alt="image-20231222151424158"></p>
<h4 id="1-普里姆-Prim-算法"><a href="#1-普里姆-Prim-算法" class="headerlink" title="1. 普里姆(Prim)算法"></a>1. 普里姆(Prim)算法</h4><p>Prim算法构造最小生成树的过程如下图所示。初始时从图中任取一顶点(如顶点加入树T，此时树中只含有一个顶点，之后选择一个与当前T中顶点集合距离最近的顶点，并将该顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1。以此类推，直至图中所有的顶点都并入T，得到的T就是最小生成树。此时T中必然有n-1条边。<br><strong>通俗点说就是：从一个顶点出发，在保证不形成回路的前提下，每找到并添加一条最短的边，就把当前形成的连通分量当做一个整体或者一个点看待，然后重复“找最短的边并添加”的操作。</strong><br><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231220201723485.png" alt="image-20231220201723485"></p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载堆的比较器</span></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">cmp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Edge* a,Edge* b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;weight&gt;b-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">unordered_set&lt;Edge*&gt; <span class="title">primMST</span><span class="params">(Graph graph)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用小顶堆来存储边，并通过边的权重比较，这样能先输出权重小的</span></span><br><span class="line">    priority_queue&lt;Edge*,vector&lt;Edge*&gt;,cmp&gt; priorityQueue;</span><br><span class="line">    unordered_set&lt;Node*&gt; set;                   <span class="comment">//定义一个集合用来判断是否加入过该节点</span></span><br><span class="line">    unordered_set&lt;Edge*&gt; result;            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node:graph.nodes)&#123;                 <span class="comment">//遍历图的节点</span></span><br><span class="line">        <span class="keyword">if</span>(!set.<span class="built_in">count</span>(node.second))&#123;            <span class="comment">//如果该点不在集合内</span></span><br><span class="line">            set.<span class="built_in">emplace</span>(node.second);           </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> edge:node.second-&gt;edges)&#123;  <span class="comment">//遍历该节点的所有边，把边放入小顶堆</span></span><br><span class="line">                priorityQueue.<span class="built_in">emplace</span>(edge);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!priorityQueue.<span class="built_in">empty</span>())&#123;      <span class="comment">//如果堆不为空，弹出边，并判断该边的下一节点是否在集合里</span></span><br><span class="line">                Edge* edge=priorityQueue.<span class="built_in">top</span>(); </span><br><span class="line">                priorityQueue.<span class="built_in">pop</span>();</span><br><span class="line">                Node* toNode=edge-&gt;to;</span><br><span class="line">                <span class="keyword">if</span>(!set.<span class="built_in">count</span>(toNode))&#123;         <span class="comment">//如果边的下一节点不在集合里，则放入集合，再把该点的所有边放入堆</span></span><br><span class="line">                    set.<span class="built_in">emplace</span>(toNode);</span><br><span class="line">                    result.<span class="built_in">emplace</span>(edge);</span><br><span class="line">                    <span class="keyword">for</span>(Edge* nextEdge:toNode-&gt;edges)&#123;</span><br><span class="line">                        priorityQueue.<span class="built_in">emplace</span>(nextEdge);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-克鲁斯卡尔（Kruskal）算法"><a href="#2-克鲁斯卡尔（Kruskal）算法" class="headerlink" title="2.克鲁斯卡尔（Kruskal）算法"></a>2.克鲁斯卡尔（Kruskal）算法</h4><p><strong>与Prim算法从顶点开始扩展最小生成树不同，Kruskal 算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。</strong></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231220202113294.png" alt="image-20231220202113294"></p>
<p><strong>代码如下：</strong></p>
<p><font color="red">不用并查集时，注意set的初始化，在for循环内初始化是会使地址一直一样，需要使用new操作符来动态分配内存</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己实现类似并查集的功能,但没有并查集快</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySets</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        unordered_map&lt;Node*,list&lt;Node*&gt;*&gt; setMap;    <span class="comment">//定义一个哈希表记录节点和它所在集合</span></span><br><span class="line">        <span class="built_in">MySets</span>(list&lt;Node*&gt; nodes)&#123;</span><br><span class="line">            list&lt;Node*&gt; *set;           <span class="comment">//必须这样初始化，不然每个循环初始时地址相同</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> cur :nodes)&#123;</span><br><span class="line">                set=<span class="keyword">new</span> <span class="built_in">list</span>&lt;Node*&gt;();  <span class="comment">//必须使用new操作符来动态分配内存，不然每个循环初始时地址相同</span></span><br><span class="line">                set-&gt;<span class="built_in">push_back</span>(cur);</span><br><span class="line">                setMap.<span class="built_in">emplace</span>(cur,set);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isSameSet</span><span class="params">(Node* from,Node* to)</span></span>&#123;</span><br><span class="line">            list&lt;Node*&gt; *fromSet= setMap[from]; </span><br><span class="line">            list&lt;Node*&gt; *toSet =setMap[to];</span><br><span class="line">            <span class="keyword">return</span> fromSet==toSet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(Node* from,Node* to)</span></span>&#123;</span><br><span class="line">            list&lt;Node*&gt; *fromSet= setMap[from];</span><br><span class="line">            list&lt;Node*&gt; *toSet =setMap[to];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> toNode:*toSet)&#123;         <span class="comment">//遍历去点的集合内所有的点，将这些点放入来点的集合，再将去点的集合更新</span></span><br><span class="line">                fromSet-&gt;<span class="built_in">push_back</span>(toNode);</span><br><span class="line">                setMap[toNode]=fromSet;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重载堆的比较器</span></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">cmp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Edge* a,Edge* b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;weight&gt;b-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//k算法不使用并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KruskalMST</span><span class="params">(Graph graph)</span></span>&#123;</span><br><span class="line">    list&lt;Node*&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node:graph.nodes)&#123;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(node.second);</span><br><span class="line">    &#125;</span><br><span class="line">    MySets* mysets=<span class="keyword">new</span> <span class="built_in">MySets</span>(tmp);</span><br><span class="line">    <span class="comment">//用小顶堆来存储边，并通过边的权重比较，这样能先输出权重小的</span></span><br><span class="line">    priority_queue&lt;Edge*,vector&lt;Edge*&gt;,cmp&gt; priorityQueue;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> edge:graph.edges)&#123;</span><br><span class="line">        priorityQueue.<span class="built_in">emplace</span>(edge);</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_set&lt;Edge*&gt; result;  <span class="comment">//可以改写一下用集合存储然后返回result</span></span><br><span class="line">    <span class="keyword">while</span>(!priorityQueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        Edge* edge=priorityQueue.<span class="built_in">top</span>();</span><br><span class="line">        priorityQueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!mysets-&gt;<span class="built_in">isSameSet</span>(edge-&gt;from,edge-&gt;to))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;该边的来点的值:&quot;</span>&lt;&lt;edge-&gt;from-&gt;value&lt;&lt;<span class="string">&quot;该边的去点的值:&quot;</span>&lt;&lt;edge-&gt;to-&gt;value&lt;&lt;<span class="string">&quot;该边权重:&quot;</span>&lt;&lt;edge-&gt;weight&lt;&lt;endl;</span><br><span class="line">            mysets-&gt;<span class="built_in">Union</span>(edge-&gt;from,edge-&gt;to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return result;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="七、最短路径"><a href="#七、最短路径" class="headerlink" title="七、最短路径"></a>七、最短路径</h3><p>在网图和非网图中，最短路径的含义是不同的。由于非网图它没有边上的权值，所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径；而<strong>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。</strong></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231222151458618.png" alt="image-20231222151458618"></p>
<h4 id="1-迪杰斯特拉-Dijkstra-算法"><a href="#1-迪杰斯特拉-Dijkstra-算法" class="headerlink" title="1. 迪杰斯特拉( Dijkstra )算法"></a>1. 迪杰斯特拉( Dijkstra )算法</h4><p>&#x3D;&#x3D;Dijkstra算法用于构建单源点的最短路径&#x3D;&#x3D;，所以也被称为<strong>单源最短路径算法</strong>，即图中某个点到任何其他点的距离都是最短的。例如，构建地图应用时查找自己的坐标离某个地标的最短距离。可以用于有向图，但是不能存在负权值。Dijkstra算法是一个贪心算法</p>
<p><strong>代码如下：</strong></p>
<ol>
<li><p>没有用堆的方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有用堆的D算法</span></span><br><span class="line"><span class="function">Node* <span class="title">getMinDistanceAndUnselectedNode</span><span class="params">(unordered_map&lt;Node*,<span class="type">int</span>&gt; distanceMap,unordered_set&lt;Node*&gt; selectedNodes)</span></span>&#123;</span><br><span class="line">    Node* minNode=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> mindistance=INT32_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> entry:distanceMap)&#123;</span><br><span class="line">        Node* node=entry.first;</span><br><span class="line">        <span class="type">int</span> distance=entry.second;</span><br><span class="line">        <span class="keyword">if</span>(!selectedNodes.<span class="built_in">count</span>(node)&amp;&amp;distance&lt;mindistance)&#123; <span class="comment">//如果没被选过，并且距离更小</span></span><br><span class="line">            minNode=node;</span><br><span class="line">            mindistance=distance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">unordered_map&lt;Node*,<span class="type">int</span>&gt; <span class="title">Dijkstra1</span><span class="params">(Node* head)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从head出发到所有点的最小距离</span></span><br><span class="line">    <span class="comment">//key：从head出发到达key</span></span><br><span class="line">    <span class="comment">//value：从head出发到达key的最小距离</span></span><br><span class="line">    <span class="comment">//如果在表中，没有T的记录，含义是从head出发到T这个点的距离为正无穷</span></span><br><span class="line">    unordered_map&lt;Node*,<span class="type">int</span>&gt; distanceMap;</span><br><span class="line">    distanceMap.<span class="built_in">emplace</span>(head,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//已经求过距离的节点，存在selectedNodes中，以后再也不碰</span></span><br><span class="line">    unordered_set&lt;Node*&gt; selectedNodes;</span><br><span class="line">    Node* minNode=<span class="built_in">getMinDistanceAndUnselectedNode</span>(distanceMap,selectedNodes);</span><br><span class="line">    <span class="keyword">while</span>(minNode!=<span class="literal">nullptr</span>)&#123; <span class="comment">//当所有节点进selectedNodes集合中就停止</span></span><br><span class="line">        <span class="type">int</span> distance=distanceMap[minNode];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge:minNode-&gt;edges)&#123;</span><br><span class="line">            Node* toNode=edge-&gt;to;</span><br><span class="line">            <span class="keyword">if</span>(!distanceMap.<span class="built_in">count</span>(toNode))&#123;     <span class="comment">//如果没在表内表示距离无穷，而现在能到该节点所以把表更新</span></span><br><span class="line">                distanceMap.<span class="built_in">emplace</span>(toNode,distance+edge-&gt;weight);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这是将之前有过的点，进行距离更新</span></span><br><span class="line">            distanceMap[toNode]=<span class="built_in">min</span>(distanceMap[toNode],distance+edge-&gt;weight);</span><br><span class="line">        &#125;</span><br><span class="line">        selectedNodes.<span class="built_in">emplace</span>(minNode);     <span class="comment">//锁住选过的点</span></span><br><span class="line">        minNode=<span class="built_in">getMinDistanceAndUnselectedNode</span>(distanceMap,selectedNodes); <span class="comment">//选下一个距离最小的没选过的点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distanceMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用堆优化的方式</p>
</li>
</ol>
<h2 id="七、贪心算法"><a href="#七、贪心算法" class="headerlink" title="七、贪心算法"></a>七、贪心算法</h2><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p><strong>贪心算法（Greedy Alogorithm）又叫登山算法</strong>，它的根本思想是逐步到达山顶，即逐步获得最优解，是解决最优化问题时的一种简单但是&#x3D;&#x3D;适用范围有限&#x3D;&#x3D;的策略。</p>
<p>贪心算法没有固定的框架，算法设计的关键是贪婪策略的选择。贪心策略要无后向性，也就是说某状态以后的过程不会影响以前的状态，至于当前状态有关。</p>
<p>贪心算法是&#x3D;&#x3D;对某些求解最优解问题的最简单、最迅速的技术&#x3D;&#x3D;。某些问题的最优解可以通过一系列的最优的选择即贪心选择来达到。但局部最优并不总能获得整体最优解，但通常能获得近似最优解。</p>
<p>在每一步贪心选择中，只考虑当前对自己最有利的选择，而不去考虑在后面看来这种选择是否合理。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="1-会议安排"><a href="#1-会议安排" class="headerlink" title="1.会议安排"></a>1.会议安排</h4><p> 一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间（给你一个数组，里面是一个个具体的项目），你来安排宣讲的日程，要求会议室进行的宣讲场次最多，返回这个最多的宣讲场次。</p>
<blockquote>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>我们按照每个项目的结束时间来进行贪心，哪个项目的结束时间早，我们就选哪个项目。定义一个以结束时间升序的优先级队列，每次从队顶中拿出一个活动，用该活动的开始时间和上一个选择了的活动的结束时间进行比较，如果满足条件，就说明能够安排这个活动。</p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Program</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> start;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        <span class="built_in">Program</span>(<span class="type">int</span> start,<span class="type">int</span> end)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;end=end;</span><br><span class="line">            <span class="keyword">this</span>-&gt;start=start;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(Program* o1,Program* o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1-&gt;end&lt;o2-&gt;end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bestArrange</span><span class="params">(vector&lt;Program*&gt; programs,<span class="type">int</span> timePoint)</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(programs.<span class="built_in">begin</span>(),programs.<span class="built_in">end</span>(),compare);</span><br><span class="line">    <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//从左往右依次遍历所有的会议</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;programs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(timePoint&lt;=programs[i]-&gt;start)&#123;</span><br><span class="line">            result++;</span><br><span class="line">            timePoint=programs[i]-&gt;end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-字符串拼接"><a href="#2-字符串拼接" class="headerlink" title="2.字符串拼接"></a>2.字符串拼接</h4><p>给定一些字符串，让你通过一定的算法来将这些字符串拼接起来，使拼接后的字符串字典序最小。<br>我们假设给定的字符串是：abfgh和kgegr，我们有2种拼接方式，第一种：abfghkgegr；第二种：kgegrabfgh。这两种拼接方式我们选择第一种，因为第一种所拼接出来的字符串的字典序小。</p>
<blockquote>
<h3 id="题目分析：-1"><a href="#题目分析：-1" class="headerlink" title="题目分析："></a>题目分析：</h3><p>我们可以设定一种贪心策略：将所有的字符串按从小到大排序，然后拼接起来。但是这种贪心策略是不对的，我们举个例子：假设有2个字符串：b，ba。我们按从小到大排序然后拼接得到的字符串是bba，但是这个字符串不是最小的，还有更小的就是bab，所以这种贪心策略是不对的。</p>
<p>假设另一种贪心策略：给定两个字符串a，b，如果a+b得到的字符串小于b+a得到的字符串，那么就把a排在前面，b排在后面</p>
<p>否则，b放在前面，a放在后面。</p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(string a, string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b&lt;b+a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">lowestString</span><span class="params">(vector&lt;string&gt; strs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;strs==<span class="literal">NULL</span>||strs.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(strs.<span class="built_in">begin</span>(),strs.<span class="built_in">end</span>(),compare);</span><br><span class="line">    string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        </span><br><span class="line">        res+=strs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-金条切分"><a href="#3-金条切分" class="headerlink" title="3.金条切分"></a>3.金条切分</h4><p>一块金条切成两半，是需要花费和长度数值相同的铜板的，比如长度为20的金条，不管切成长度为多大的两半，都需要花费20个铜板，一群人想整分整块金条，怎么分最省铜板？</p>
<p>例如：给定数组【10,20,30】，代表一共三个人，整块金条的长度为10+20+30&#x3D;60，金条要分成10,20,30三个部分。如果，先把长度为60的金条分成10和50，花费60，在办长度为50的金条分成20和30，花费50，一共花费110铜板。<br>但是如果先把长度为60的金条分成30和30的，在把长度为30的金条分成10和20，一共花费90铜板。<br>输入一个数组，输出分割最小代价。</p>
<blockquote>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>利用哈夫曼编码，每次选取数组中最小和次小的两个元素进行合并，然后把合并后的数字重新放入数组中去，然后重复进行上述过程，直到数组中只有一个数字时停止。（和找最优二叉树的算法一模一样——哈夫曼算法）</p>
<p>上述过程完成后可以生成一个二叉树，我们以【10,20,30】举例：</p>
</blockquote>
<h2 id="八、查找"><a href="#八、查找" class="headerlink" title="八、查找"></a>八、查找</h2><img src="/MyBlog/.io//image-20231128093802534.png" alt="image-20231128093802534" style="zoom:50%;">

<h3 id="一、查找的基本概念"><a href="#一、查找的基本概念" class="headerlink" title="一、查找的基本概念"></a>一、查找的基本概念</h3><p><strong>查找(Searching)<strong>：就是根据给定的某个值，在</strong>查找表</strong>中确定一个其<strong>关键字</strong>等于给定值的数据元素( 或记录)。</p>
<p>**查找表(Search Table)**：是由同一类型的数据元素(或记录)构成的集合。</p>
<p>**关键字(Key)**：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在由一个学生元素构成的数据集合中，学生元素中“学号”这一数据项的值唯一地标识一名学生。</p>
<p>**静态查找表(Static Search Table)**：只作查找操作的查找表。</p>
<ul>
<li>主要操作</li>
</ul>
<ol>
<li>查询某个“特定的”数据元素是否在查找表中。</li>
<li>检索某个“特定的”数据元素和各种属性。</li>
</ol>
<p>**动态查找表(Dynamic Search Table)**： 在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。</p>
<ul>
<li>主要操作</li>
</ul>
<ol>
<li>查找时插入不存在的数据元素。</li>
<li>查找时删除已存在的数据元素。</li>
</ol>
<p>&#x3D;&#x3D;<strong>平均查找长度</strong>&#x3D;&#x3D;：在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度，则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为<br>$$<br>ASL&#x3D;\sum^n_{i&#x3D;1}P_iC_i<br>$$<br>这个式子中，n是查找表的长度；$P_i$是查找第$i$个数据元素的概率，一般认为每个数据元素的查找概率相等，即$P_i&#x3D;\frac{1}n$;$C_i$是找到第$i$个数据元素所需进行的比较次数。平均查找长度是衡量查找算法效率的最主要的指标。</p>
<h3 id="二、顺序表查找"><a href="#二、顺序表查找" class="headerlink" title="二、顺序表查找"></a>二、顺序表查找</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p><strong>顺序查找(Sequential Search) 又叫线性查找</strong>，是最基本的查找技术，作为一种最直观的查找方法，其基本思想是从线性表的一端开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。</p>
<h4 id="2-算法"><a href="#2-算法" class="headerlink" title="2.算法"></a>2.算法</h4><p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*有哨兵顺序查找*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sequential_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	a[<span class="number">0</span>] = key;	<span class="comment">//设置a[0]为关键字，称之为“哨兵”</span></span><br><span class="line">	i = n;	<span class="comment">//循环从数组尾部开始</span></span><br><span class="line">	<span class="keyword">while</span>(a[i] != key)&#123;</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;	<span class="comment">//返回0则说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法分析：</strong></p>
<blockquote>
<p>这种在查找方向的尽头放置“哨兵”免去了在查找过程中每一次比较后都要判断查找位置是否越界的小技巧，看似与原先差别不大，但在总数据较多时，效率提高很大，是非常好的编码技巧。<br>上述顺序表查找时间复杂度是$O(n)$</p>
</blockquote>
<h3 id="三、顺序查找的应用"><a href="#三、顺序查找的应用" class="headerlink" title="三、顺序查找的应用"></a>三、顺序查找的应用</h3><h4 id="1-查找最大值和最小值"><a href="#1-查找最大值和最小值" class="headerlink" title="1.查找最大值和最小值"></a>1.查找最大值和最小值</h4><p>查找顺序表中的最大值和最小值，比较次数不超过$\frac32 n$</p>
<blockquote>
<p>算法1：朴素查找法——比较次数：2(n-1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">findmaxandmin</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line"> <span class="type">int</span> min=arr[<span class="number">0</span>];</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(max&lt;arr[i]) max=arr[i];</span><br><span class="line">     <span class="keyword">if</span>(min&gt;arr[i]) min=arr[i];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> res[<span class="number">0</span>]=max;</span><br><span class="line"> res[<span class="number">1</span>]=min;</span><br><span class="line"> <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法2：快速查找法——比较次数$\frac32 n$</p>
<p>先比较两者，再用较小值和较大值分别与最小值和最大值比较</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res2[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">findmaxandmin2</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> min=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> k=n%<span class="number">2</span>;<span class="comment">//n是奇数，k从1开始，否则从0开始</span></span><br><span class="line">    <span class="keyword">while</span> (k&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[k]&lt;arr[k<span class="number">+1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(min&gt;arr[k]) min=arr[k];</span><br><span class="line">            <span class="keyword">if</span>(max&lt;arr[k<span class="number">+1</span>]) max=arr[k<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(min&gt;arr[k<span class="number">+1</span>]) min=arr[k<span class="number">+1</span>];</span><br><span class="line">            <span class="keyword">if</span>(max&lt;arr[k]) max=arr[k];</span><br><span class="line">        &#125;</span><br><span class="line">        k=k<span class="number">+2</span>; <span class="comment">//每次同时比较两个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    res2[<span class="number">0</span>]=max;</span><br><span class="line">    res2[<span class="number">1</span>]=min;</span><br><span class="line">    <span class="keyword">return</span> res2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="2-查找区间内所有质数"><a href="#2-查找区间内所有质数" class="headerlink" title="2.查找区间内所有质数"></a>2.查找区间内所有质数</h4><p>查找正整数区间[1,n]（n&gt;1）内所有质数。</p>
<h5 id="1-试除法-——时间复杂度-O-n-sqrt-n"><a href="#1-试除法-——时间复杂度-O-n-sqrt-n" class="headerlink" title="(1).试除法 ——时间复杂度$O(n\sqrt n)$"></a>(1).试除法 ——时间复杂度$O(n\sqrt n)$</h5><p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个数是否是质数的函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1和负数都不是质数</span></span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 2是唯一的偶数质数</span></span><br><span class="line">  <span class="keyword">if</span> (num == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 其他偶数都不是质数</span></span><br><span class="line">  <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 从3开始，每次加2，只检查奇数因子</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="built_in">sqrt</span>(num); i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果有任何因子可以整除，就不是质数</span></span><br><span class="line">    <span class="keyword">if</span> (num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有找到任何因子，就是质数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 输入n的值</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;请输入n的值：&quot;</span>;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="comment">// 遍历区间[1,n]，输出所有质数</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;区间[1,&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;]内的所有质数如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isPrime</span>(i)) &#123;</span><br><span class="line">      cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-埃氏筛选法——时间复杂度-O-nloglog-n"><a href="#2-埃氏筛选法——时间复杂度-O-nloglog-n" class="headerlink" title="(2)埃氏筛选法——时间复杂度:O(nloglog(n))"></a>(2)埃氏筛选法——时间复杂度:O(nloglog(n))</h5><p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用埃式筛选法查找正整数区间[1,n]内所有质数的函数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">eratosthenes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; primes; <span class="comment">// 存储找到的素数</span></span><br><span class="line">  <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">is_prime</span><span class="params">(n + <span class="number">1</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// 标记每个数是否是素数，初始都为true</span></span><br><span class="line">  is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 0和1不是素数，标记为false</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) &#123; <span class="comment">// 如果i是素数，就把它加入到primes中</span></span><br><span class="line">      primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">      <span class="comment">// 用i的倍数从i*i开始筛掉所有能被i整除的数，因为小于i*i的合数已经被更小的素数筛掉了</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += i) &#123;</span><br><span class="line">        is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> primes; <span class="comment">// 返回素数的向量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 输入n的值</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;请输入n的值：&quot;</span>;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="comment">// 调用eratosthenes函数，得到区间[1,n]内的所有素数</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; primes = <span class="built_in">eratosthenes</span>(n);</span><br><span class="line">  <span class="comment">// 输出素数</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;区间[1,&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;]内的所有素数如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> p : primes) &#123;</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="3-合数限定法——时间复杂度：O-n"><a href="#3-合数限定法——时间复杂度：O-n" class="headerlink" title="(3)合数限定法——时间复杂度：O(n)"></a>(3)合数限定法——时间复杂度：O(n)</h5><p><strong>代码如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="4-欧拉筛选法——时间复杂度-O-n"><a href="#4-欧拉筛选法——时间复杂度-O-n" class="headerlink" title="(4)欧拉筛选法——时间复杂度:O(n)"></a>(4)欧拉筛选法——时间复杂度:O(n)</h5><p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用欧拉筛选法查找正整数区间[1,n]内所有质数的函数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">euler</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; primes; <span class="comment">// 存储找到的素数</span></span><br><span class="line">  <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">is_prime</span><span class="params">(n + <span class="number">1</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// 标记每个数是否是素数，初始都为true</span></span><br><span class="line">  is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>; <span class="comment">// 0和1不是素数，标记为false</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123; <span class="comment">// i从2循环到n（外层循环）</span></span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) primes.<span class="built_in">push_back</span>(i); <span class="comment">// 如果i没有被前面的数筛掉，则i是素数，加入到primes中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; primes.<span class="built_in">size</span>() &amp;&amp; i * primes[j] &lt;= n; j++) &#123; <span class="comment">// 筛掉i的素数倍，即i的primes[j]倍</span></span><br><span class="line">      <span class="comment">// j循环枚举现在已经筛出的素数（内层循环）</span></span><br><span class="line">      is_prime[i * primes[j]] = <span class="literal">false</span>; <span class="comment">// 倍数标记为合数，也就是i用primes[j]把i * primes[j]筛掉了</span></span><br><span class="line">      <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 最神奇的一句话，如果i整除primes[j]，退出循环</span></span><br><span class="line">      <span class="comment">// 这样可以保证线性的时间复杂度</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> primes; <span class="comment">// 返回素数的向量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 输入n的值</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;请输入n的值：&quot;</span>;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="comment">// 调用euler函数，得到区间[1,n]内的所有素数</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; primes = <span class="built_in">euler</span>(n);</span><br><span class="line">  <span class="comment">// 输出素数</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;区间[1,&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;]内的所有素数如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> p : primes) &#123;</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、有序表查找"><a href="#四、有序表查找" class="headerlink" title="四、有序表查找"></a>四、有序表查找</h3><h4 id="1-折半查找"><a href="#1-折半查找" class="headerlink" title="1.折半查找"></a>1.折半查找</h4><p><strong>折半查找(Binary Search)技术，又称为二分查找。</strong>它的前提是线性表中的记录&#x3D;&#x3D;必须是关键码有序(通常从小到大有序)&#x3D;&#x3D;，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现方法1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch1</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low=left;</span><br><span class="line">    <span class="type">int</span> high=right;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;	<span class="comment">//取中间位置</span></span><br><span class="line">		<span class="keyword">if</span>(arr[mid] == key)&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;	<span class="comment">//查找成功返回所在位置</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; key)&#123;</span><br><span class="line">			high = mid - <span class="number">1</span>;	<span class="comment">//从前半部分继续查找</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			low = mid + <span class="number">1</span>;	<span class="comment">//从后半部分继续查找</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">//查找失败，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现方法2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low=left<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> high=right<span class="number">+1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(high&gt;low<span class="number">+1</span>)&#123;</span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;	<span class="comment">//取中间位置</span></span><br><span class="line">		<span class="keyword">if</span>(arr[mid] == key)&#123;</span><br><span class="line">			<span class="keyword">return</span> mid;	<span class="comment">//查找成功返回所在位置</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; key)&#123;</span><br><span class="line">			high = mid ;	<span class="comment">//从前半部分继续查找</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			low = mid ;	<span class="comment">//从后半部分继续查找</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">//查找失败，返回-1    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-二分查找的应用"><a href="#2-二分查找的应用" class="headerlink" title="2.二分查找的应用"></a>2.二分查找的应用</h4><h5 id="1-区间查询"><a href="#1-区间查询" class="headerlink" title="1.区间查询"></a>1.区间查询</h5><img src="/MyBlog/.io//image-20231128155657543.png" alt="image-20231128155657543" style="zoom:50%;">

<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SearchinInterval</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low=left<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> high=right<span class="number">+1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(high&gt;low<span class="number">+1</span>)&#123;</span><br><span class="line">        mid = (low + high)/<span class="number">2</span>;	<span class="comment">//取中间位置</span></span><br><span class="line">		<span class="keyword">if</span>(arr[mid] &gt;= key)&#123;</span><br><span class="line">			high = mid ;	</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			low = mid ;	<span class="comment">//从后半部分继续查找</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> high;<span class="comment">//或者 low;	// high :&gt;=key的最小值位置 low:&lt;key的最大值位置   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-快速求幂"><a href="#2-快速求幂" class="headerlink" title="2.快速求幂"></a>2.快速求幂</h5><p>给定正整数a和n，求$a^n$的值</p>
<blockquote>
<p>法一：直接迭代：$a^n&#x3D;a^n-1*a$  ——时间复杂度O(n)</p>
<p>法二：二分递归：$a^n&#x3D;a^{\frac n2}*a^{\frac n2}*a^{n%2}$——时间复杂度O(log(n))</p>
</blockquote>
<p><strong>代码如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Power</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pow=<span class="built_in">Power</span>(x,n/<span class="number">2</span>);</span><br><span class="line">    pow=pow*pow;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">        pow=pow*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-快速查找"><a href="#3-快速查找" class="headerlink" title="3.快速查找"></a>3.快速查找</h5><p>查找未排序序列$&lt;a_1,a_2.\dots,a_n&gt;$中的第k小元素</p>
<blockquote>
<p>法一: 循环k次选择排序或冒泡排序 ——时间复杂度O(kn)</p>
<p>法二：快速或递归排序——时间复杂度：O(nlogn)[排序]+O(1)[找第k小元素]</p>
<p>法三： 快速建最小堆+k次出堆——时间复杂度：O(n)+O(klogn)</p>
<p>法四：利用快速排序的partition过程，进行二分——时间复杂度：O(n)</p>
</blockquote>
<p><strong>法四，代码如下：（注意k输入时要-1）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> L = begin,R = end,key = begin;<span class="comment">//定义L,R,key下标</span></span><br><span class="line">    <span class="keyword">while</span>(L &lt; R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[R] &gt;= a[key] &amp;&amp; L &lt; R)<span class="comment">//右边先走，右边大于等于key就一直走下去，否则停下来，加上判断L &lt; R，防止越界</span></span><br><span class="line">        &#123;</span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(a[L] &lt;= a[key] &amp;&amp; L &lt; R)<span class="comment">//同理</span></span><br><span class="line">        &#123;</span><br><span class="line">            L++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(&amp;a[L],&amp;a[R]);<span class="comment">//都停下来后交换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;a[key],&amp;a[R]);<span class="comment">//最后key值和相遇点交换</span></span><br><span class="line">    <span class="keyword">return</span> R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QuickSearch</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> left,<span class="type">int</span> right, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> m=<span class="built_in">Partition</span>(arr,left,right);</span><br><span class="line">        <span class="keyword">if</span>(m==k) <span class="keyword">return</span> arr[m];</span><br><span class="line">        <span class="keyword">if</span>(m&lt;k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">QuickSearch</span>(arr,m<span class="number">+1</span>,right,k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">QuickSearch</span>(arr,left,m<span class="number">-1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、线性索引查找"><a href="#五、线性索引查找" class="headerlink" title="五、线性索引查找"></a>五、线性索引查找</h3><p>索引按照结构可以分为<strong>线性索引、树形索引和多级索引</strong>。<br>这里主要介绍线性索引，所谓线性索引就是将索引项集合组织为线性结构，也称为<strong>索引表</strong>。我们重点介绍三种线性索引：<strong>稠密索引、分块索引和倒排索引</strong>。</p>
<h3 id="六、动态查找"><a href="#六、动态查找" class="headerlink" title="六、动态查找"></a>六、动态查找</h3><h4 id="一、二叉排序树（二叉查找树）"><a href="#一、二叉排序树（二叉查找树）" class="headerlink" title="一、二叉排序树（二叉查找树）"></a>一、二叉排序树（二叉查找树）</h4><p>**二叉排序树(也称二叉查找树)**或者是一棵空树，或者是具有下列特性的二叉树:</p>
<ol>
<li>若左子树非空，则左子树上所有结点的值均小于根结点的值。</li>
<li>若右子树非空，则右子树上所有结点的值均大于根结点的值。</li>
<li>左、右子树也分别是一棵二叉排序树。</li>
</ol>
<p>根据二叉排序树的定义，&#x3D;&#x3D;左子树结点值&lt;根结点值&lt;右子树结点值&#x3D;&#x3D;，所以对二叉排序树进行中序遍历，可以得到一个&#x3D;&#x3D;递增的有序序列&#x3D;&#x3D;。例如，下图所示二叉排序树的中序遍历序列为123468。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210309095505317.png" alt="在这里插入图片描述"></p>
<h5 id="1-二叉排序树的查找"><a href="#1-二叉排序树的查找" class="headerlink" title="1. 二叉排序树的查找"></a><font size="4">1. 二叉排序树的查找</font></h5><p>  假设我们要查找的值为value，我们从根结点开始，比较结点的值和value的大小：</p>
<ul>
<li><p>如果结点的值等于value，返回该结点</p>
</li>
<li><p>如果结点的值比value小，那么在左子树查找</p>
</li>
<li><p>如果结点的值比value大，那么在右子树查找</p>
<p>可以用递归或者迭代</p>
</li>
</ul>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">SearchBSTRecur</span><span class="params">(TreeNode* bst,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bst==<span class="literal">nullptr</span>||bst-&gt;val==key)&#123;</span><br><span class="line">        <span class="keyword">return</span> bst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key&lt;bst-&gt;val)&#123; <span class="comment">//key的值小于根，往左子树查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBSTRecur</span>(bst-&gt;left,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//key的值大于根，往右子树查找</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchBSTRecur</span>(bst-&gt;right,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">SearchBSTUnRecur</span><span class="params">(TreeNode* bst,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    TreeNode* node=bst;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="literal">nullptr</span> &amp;&amp; node-&gt;val!=key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;node-&gt;val)&#123;<span class="comment">//key的值小于根，往左子树查找</span></span><br><span class="line">            node=node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//key的值大于根，往右子树查找</span></span><br><span class="line">            node=node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-二叉排序树的插入"><a href="#2-二叉排序树的插入" class="headerlink" title="2. 二叉排序树的插入"></a><font size="4">2. 二叉排序树的插入</font></h5><p>  插入就是查找到一个能插入的位置，所以和上面查找的过程很类似。<br>  假设我们要插入的值为value，我们从根结点开始，比较结点的值和value的大小：</p>
<ul>
<li><p>如果结点的值比value小，那么就看结点的右子树是否为空，如果为空就将value插入到结点的右子树，如果不为空就在右子树递归插入</p>
</li>
<li><p>如果结点的值比value大，那么就看结点的左子树是否为空，如果为空就将value插入到结点的左子树，如果不为空就在左子树递归插入</p>
</li>
</ul>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">InsertRecur</span><span class="params">(TreeNode* bst,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bst==<span class="literal">nullptr</span>)&#123; <span class="comment">// 如果当前节点不存在，则插入新的节点</span></span><br><span class="line">        bst=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;bst-&gt;val)&#123; <span class="comment">//key的值小于根，往左子树插</span></span><br><span class="line">        bst-&gt;left=<span class="built_in">InsertRecur</span>(bst-&gt;left,key);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;bst-&gt;val)&#123; <span class="comment">//key的值大于根，往右子树插</span></span><br><span class="line">        bst-&gt;right=<span class="built_in">InsertRecur</span>(bst-&gt;right,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bst; <span class="comment">//当key的值等于根，说明已经有该节点或者已经插入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">InsertUnRecur</span><span class="params">(TreeNode* bst,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    TreeNode* node =bst;</span><br><span class="line">    TreeNode* father=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(node!=<span class="literal">nullptr</span>&amp;&amp;node-&gt;val!=key)&#123; <span class="comment">//直到查找到有这个节点或者不存在为止</span></span><br><span class="line">        father=node;  </span><br><span class="line">        <span class="keyword">if</span>(key&lt;node-&gt;val)&#123;  <span class="comment">//将node下移</span></span><br><span class="line">            node=node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            node-node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)&#123; <span class="comment">//如果该节点不存在</span></span><br><span class="line">        node=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(key);  <span class="comment">//建立新节点</span></span><br><span class="line">        <span class="keyword">if</span>(father==<span class="literal">nullptr</span>)&#123; <span class="comment">//如果father=null说明整棵树不存在</span></span><br><span class="line">            bst=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;father-&gt;val)&#123;  <span class="comment">//如果小于父亲节点的值，则插入到左子树</span></span><br><span class="line">            father-&gt;left=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;  <span class="comment">//如果大于父亲节点的值，则插入到右子树</span></span><br><span class="line">            father-&gt;right=node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-二叉排序树的删除"><a href="#3-二叉排序树的删除" class="headerlink" title="3. 二叉排序树的删除"></a><font size="4">3. 二叉排序树的删除</font></h5><p>二叉排序树的查找和插入都很简单，但是删除操作就要复杂一些，此时要删除的结点有三种情况：</p>
<ol>
<li>叶子结点；</li>
<li>仅有左或右子树的结点；</li>
<li>左右子树都有的结点；</li>
</ol>
<p>前两种情况都很简单，第一种只需删除该结点不需要做其他操作；第二种删除后需让被删除结点的直接后继接替它的位置；<strong>复杂就复杂在第三种，此时我们需要遍历得到被删除结点的直接前驱或者直接后继来接替它的位置，然后再删除。</strong><br>第三种情况如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210309100019953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">RemovalRecur</span><span class="params">(TreeNode* bst,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bst==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> bst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bst-&gt;val&gt;key)&#123; <span class="comment">//往左子树找</span></span><br><span class="line">        bst-&gt;left=<span class="built_in">RemovalRecur</span>(bst-&gt;left,key);</span><br><span class="line">        <span class="keyword">return</span> bst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bst-&gt;val&lt;key)&#123;  <span class="comment">//往右子树找</span></span><br><span class="line">        bst-&gt;right=<span class="built_in">RemovalRecur</span>(bst-&gt;right,key);</span><br><span class="line">        <span class="keyword">return</span> bst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!bst-&gt;left&amp;&amp;!bst-&gt;right)&#123; <span class="comment">//左右都为空，把该节点删了，直接返回空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(bst-&gt;left==<span class="literal">nullptr</span>)&#123; <span class="comment">//左子树为空，将右子树作为新子树，返回右子节点</span></span><br><span class="line">            <span class="keyword">return</span> bst-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bst-&gt;right==<span class="literal">nullptr</span>)&#123; <span class="comment">//右子树为空，将左子树作为新子树，返回左子节点</span></span><br><span class="line">            <span class="keyword">return</span> bst-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右都有子树</span></span><br><span class="line">        TreeNode* minRight=bst-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (minRight-&gt;left) <span class="comment">//找后继节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            minRight=minRight-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        bst-&gt;right=<span class="built_in">RemovalRecur</span>(bst-&gt;right,minRight-&gt;val); <span class="comment">//递归调用删除minRight</span></span><br><span class="line">        <span class="comment">//将minRight更新为新的根节点返回，相当于交换了根节点删除</span></span><br><span class="line">        minRight-&gt;right=bst-&gt;right;</span><br><span class="line">        minRight-&gt;left=bst-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> minRight;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> bst;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">RemovalUnRecur</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    TreeNode *cur = root, *curParent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;val != key) &#123;</span><br><span class="line">        curParent = cur;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &gt; key) &#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) &#123;</span><br><span class="line">        cur = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cur-&gt;right) &#123;</span><br><span class="line">        cur = cur-&gt;left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cur-&gt;left) &#123;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode *successor = cur-&gt;right, *successorParent = cur;</span><br><span class="line">        <span class="keyword">while</span> (successor-&gt;left) &#123;</span><br><span class="line">            successorParent = successor;</span><br><span class="line">            successor = successor-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (successorParent-&gt;val == cur-&gt;val) &#123;</span><br><span class="line">            successorParent-&gt;right = successor-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            successorParent-&gt;left = successor-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        successor-&gt;right = cur-&gt;right;</span><br><span class="line">        successor-&gt;left = cur-&gt;left;</span><br><span class="line">        cur = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!curParent) &#123;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curParent-&gt;left &amp;&amp; curParent-&gt;left-&gt;val == key) &#123;</span><br><span class="line">            curParent-&gt;left = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curParent-&gt;right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="二、平衡二叉树-AVL树"><a href="#二、平衡二叉树-AVL树" class="headerlink" title="二、平衡二叉树(AVL树)"></a>二、平衡二叉树(AVL树)</h4><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h5><p><strong>平衡二叉树(Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree)是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1</strong>。<br>它是一种高度平衡的二叉排序树。它要么是一棵空树， 要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。我们将<strong>二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF (Balance Factor)</strong> ， 那么平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70-17028912471813.png" alt="在这里插入图片描述"></p>
<h5 id="2-平衡二叉树的查找"><a href="#2-平衡二叉树的查找" class="headerlink" title="2.平衡二叉树的查找"></a>2.平衡二叉树的查找</h5><p>平衡二叉树的查找直接调用二叉排序树的查找即可</p>
<h5 id="3-平衡二叉树的插入和删除"><a href="#3-平衡二叉树的插入和删除" class="headerlink" title="3.平衡二叉树的插入和删除"></a>3.平衡二叉树的插入和删除</h5><p>二叉排序树保证平衡的<strong>基本思想</strong>如下：&#x3D;&#x3D;每当在二叉排序树中插入(或删除)一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。&#x3D;&#x3D;若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A，再对以A为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。<br><strong>注意:每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。下图中的虚线框内为最小不平衡子树。</strong></p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70-17028917359526.png" alt="在这里插入图片描述"></p>
<p>平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列4种情况：</p>
<ol>
<li>**LL平衡旋转(右单旋转)**。<font color="red">由于在结点A的左孩子(L)的左子树(L)上插入了新结点</font>，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次<font color="red">向右</font>的旋转操作。将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。</li>
</ol>
<p>如下图所示，结点旁的数值代表结点的平衡因子，而用方块表示相应结点的子树，下方数值代表该子树的高度。</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/20210309101721760.png" alt="img"></p>
<ol start="2">
<li>**RR平衡旋转(左单旋转)**。类1.</li>
</ol>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/2021030910190515.png" alt="在这里插入图片描述"></p>
<ol start="3">
<li>**LR平衡旋转(先左后右双旋转)**。由于在A的左孩子的右子树上插入新节点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。</li>
</ol>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70-170289262930113.png" alt="在这里插入图片描述"></p>
<ol start="4">
<li>**RL平衡旋转(先右后左双旋转)**。</li>
</ol>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlYWxfRm9vbF8=,size_16,color_FFFFFF,t_70-170289265566016.png" alt="在这里插入图片描述"></p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateHeight</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="type">int</span> leftHeight=<span class="built_in">getHeight</span>(node-&gt;left); <span class="comment">//左子树高度</span></span><br><span class="line">        <span class="type">int</span> rightHeight=<span class="built_in">getHeight</span>(node-&gt;right); <span class="comment">//右子树高度</span></span><br><span class="line">        node-&gt;height=<span class="built_in">max</span>(leftHeight,rightHeight)<span class="number">+1</span>; <span class="comment">//更新该节点高度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getBalance</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getHeight</span>(node-&gt;left) - <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对AVL树插入与删除后的维护平衡</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">Balancing</span><span class="params">(TreeNode* root,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 计算当前节点的平衡因子</span></span><br><span class="line">    <span class="type">int</span> balance = <span class="built_in">getBalance</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果平衡因子的绝对值大于1，说明树不平衡，需要进行旋转操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左左情况，对当前节点进行右旋</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; val &lt; root-&gt;left-&gt;val) <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右情况，先对左子节点进行左旋，然后对当前节点进行右旋</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; val &gt; root-&gt;left-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">leftRotate</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rightRotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 右右情况，对当前节点进行左旋</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; val &gt; root-&gt;right-&gt;val) <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右左情况，先对右子节点进行右旋，然后对当前节点进行左旋</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; val &lt; root-&gt;right-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">rightRotate</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">leftRotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果树平衡，直接返回当前节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入操作可以直接调用BST中的插入算法</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">insert</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果树为空，直接创建一个新的节点作为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果值小于当前节点的值，递归地向左子树插入</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="built_in">insert</span>(root-&gt;left, val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果值大于当前节点的值，递归地向右子树插入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) root-&gt;right = <span class="built_in">insert</span>(root-&gt;right, val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果值等于当前节点的值，不进行插入，直接返回当前节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入后，更新当前节点的高度</span></span><br><span class="line">    <span class="built_in">UpdateHeight</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回经过平衡后的节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Balancing</span>(root,val);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果树为空，直接返回空</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要删除的值小于当前节点的值，递归地向左子树删除</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要删除的值大于当前节点的值，递归地向右子树删除</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要删除的值等于当前节点的值，分为以下几种情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果节点没有子节点，直接删除节点，并返回空</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果节点只有一个子节点，直接用子节点替换节点，并返回子节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> || root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* child = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line">            <span class="keyword">delete</span> root;</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果节点有两个子节点，找到节点的后继节点（右子树的最小节点），用后继节点的值替换节点的值，然后递归地在右子树删除后继节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* successor = root-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (successor-&gt;left) successor = successor-&gt;left;</span><br><span class="line">            root-&gt;val = successor-&gt;val;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, successor-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除后，更新当前节点的高度</span></span><br><span class="line">    <span class="built_in">UpdateHeight</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回平衡后的节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Balancing</span>(root,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="散列表查找（哈希表）"><a href="#散列表查找（哈希表）" class="headerlink" title="散列表查找（哈希表）"></a>散列表查找（哈希表）</h3><h4 id="一、散列表查找的基本概念"><a href="#一、散列表查找的基本概念" class="headerlink" title="一、散列表查找的基本概念"></a>一、散列表查找的基本概念</h4><p><strong>散列表</strong>是根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。我们只需要通过某个函数f，使得<br>$$<br>存储位置&#x3D;f(关键字)<br>$$<br>&#x3D;&#x3D;那样我们可以通过查找关键字不需要比较就可获得需要的记录的存储位置。&#x3D;&#x3D;</p>
<p><strong>散列技术</strong>既是一种存储方法， 也是一种查找方法，散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置$f(key)$</p>
<p>这里我们把这种对应关系f称为<strong>散列函数</strong>，又称为<strong>哈希(Hash) 函数</strong>。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为<strong>散列表</strong>或<strong>哈希表(Hash table)<strong>。那么关键字对应的记录存储位置我们称为</strong>散列地址</strong>。</p>
<p>&#x3D;&#x3D;散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为<strong>冲突</strong>&#x3D;&#x3D;，这些发生碰撞的不同关键字称为<strong>同义词</strong>。一方面，设计得好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法</p>
<h4 id="二、散列函数的构造方法"><a href="#二、散列函数的构造方法" class="headerlink" title="二、散列函数的构造方法"></a>二、散列函数的构造方法</h4><p>在构造散列函数时，必须注意以下几点：</p>
<ol>
<li>散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。</li>
<li>散列函数计算出来的地址应该能&#x3D;&#x3D;等概率、均匀&#x3D;&#x3D;地分布在整个地址空间中，从而减少冲突的发生。</li>
<li>散列函数&#x3D;&#x3D;应尽量简单，能够在较短&#x3D;&#x3D;的时间内计算出任一关键字对应的散列地址。</li>
</ol>
<p>下面介绍常用的散列函数。</p>
<h5 id="1、直接定址法"><a href="#1、直接定址法" class="headerlink" title="1、直接定址法"></a>1、直接定址法</h5><p>直接取关键字的某个&#x3D;&#x3D;线性函数值&#x3D;&#x3D;为散列地址，散列函数为<br>$$<br>H(key)&#x3D;key或H(key)&#x3D;a*key+b<br>$$<br>这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</p>
<p>有反函数，容易反解得到key</p>
<p>举例：0~100岁的人口数字统计表，可以吧年龄数值直接当做散列地址。</p>
<h5 id="2、数字分析法"><a href="#2、数字分析法" class="headerlink" title="2、数字分析法"></a>2、数字分析法</h5><p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231219144205682.png" alt="image-20231219144205682"></p>
<h5 id="3、平方取中法"><a href="#3、平方取中法" class="headerlink" title="3、平方取中法"></a>3、平方取中法</h5><p>取关键字平方后的中间几位作为散列地址，即散列函数为：<br>$$<br>H(key)&#x3D;key^2的中间几位<br>$$<br>其中，所取位数由散列表大小确定</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231219144318829.png" alt="image-20231219144318829"></p>
<h5 id="4、折叠法"><a href="#4、折叠法" class="headerlink" title="4、折叠法"></a>4、折叠法</h5><p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231219145419526.png" alt="image-20231219145419526"></p>
<h5 id="5、除留余数法"><a href="#5、除留余数法" class="headerlink" title="5、除留余数法"></a>5、除留余数法</h5><p>这是一种&#x3D;&#x3D;最简单、最常用&#x3D;&#x3D;的方法，假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址。散列函数为<br>$$<br>H(key)&#x3D;key%p(p\le m)<br>$$<br>事实上，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。</p>
<p>其中p的选择很重要，不然会产生很多冲突。</p>
<h5 id="6、随机数法"><a href="#6、随机数法" class="headerlink" title="6、随机数法"></a>6、随机数法</h5><p>选择一个随机函数，取关键字的随机函数值为它的散列地址。<br>$$<br>H(key)&#x3D; random(key)<br>$$<br>其中random为随机函数。&#x3D;&#x3D;当关键字长度不等时，采用这个方法构造散列函数比较合适。&#x3D;&#x3D;</p>
<h4 id="三、处理散列冲突"><a href="#三、处理散列冲突" class="headerlink" title="三、处理散列冲突"></a>三、处理散列冲突</h4><h5 id="1、开放地址法"><a href="#1、开放地址法" class="headerlink" title="1、开放地址法"></a>1、开放地址法</h5><p><strong>所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址</strong>，只要散列表足够大，空的散列地址总能找到，并将记录存入。<br>它的公式是：<br>$$<br>H_i(key)&#x3D;(H(key)+d_i)%m<br>$$<br>式中，H(key)为散列函数；$i&#x3D;0,1,2,\dots,k(k\le m-1)$ m为散列表长</p>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231219145911590.png" alt="image-20231219145911590"></p>
<h5 id="2、再散列法"><a href="#2、再散列法" class="headerlink" title="2、再散列法"></a>2、再散列法</h5><h4 id="四、散列表查找算法"><a href="#四、散列表查找算法" class="headerlink" title="四、散列表查找算法"></a>四、散列表查找算法</h4><p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231219152538976.png" alt="image-20231219152538976"></p>
<h2 id="九、暴力递归"><a href="#九、暴力递归" class="headerlink" title="九、暴力递归"></a>九、暴力递归</h2><p><strong>暴力递归就是尝试</strong></p>
<ol>
<li>把问题转化为规模缩小了的同类问题的子问题</li>
<li>有明确的不需要继续进行递归的条件（base case)</li>
<li>有当得到了子问题的结果之后的决策过程</li>
<li>不记录每一个子问题的解</li>
</ol>
<h3 id="一、汉诺塔问题"><a href="#一、汉诺塔问题" class="headerlink" title="一、汉诺塔问题"></a>一、汉诺塔问题</h3><p>有三个可以使用的杆，将从大到小摆放的圆盘移到另一个杆子上。圆盘在的杆子为from，圆盘要去的杆子为to，剩下的杆子叫other</p>
<ul>
<li>把i-1从from移到other</li>
<li>把i从from移到end</li>
<li>把i-1从other移到end</li>
</ul>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把i拆成i-1，其中三步，i-1到中，i到右，i-1到右</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i,string start,string end,string other)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;    <span class="comment">//base case</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Move 1 from &quot;</span>&lt;&lt;start&lt;&lt;<span class="string">&quot; to &quot;</span>&lt;&lt;end&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">func</span>(i<span class="number">-1</span>,start,other,end);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Move &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot; from &quot;</span>&lt;&lt;start&lt;&lt;<span class="string">&quot; to &quot;</span>&lt;&lt;end&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">func</span>(i<span class="number">-1</span>,other,end,start);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hanoi</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">func</span>(n,<span class="string">&quot;左&quot;</span>,<span class="string">&quot;右&quot;</span>,<span class="string">&quot;中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、打印一个字符串的全部子序列（子集），包括空字符串"><a href="#二、打印一个字符串的全部子序列（子集），包括空字符串" class="headerlink" title="二、打印一个字符串的全部子序列（子集），包括空字符串"></a>二、打印一个字符串的全部子序列（子集），包括空字符串</h3><p><strong>解决方法：</strong></p>
<ul>
<li>遍历所有的字符，每个字符都有两种处理方式，要或者不要</li>
<li>处理要和不要两种状态，如果要，将字符加到要输出的list中，如果不要，就不加字符</li>
<li>遍历到最后一个字符，将其输出</li>
</ul>
<p><img src="/MyBlog/.io//%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93.assets/image-20231225101526345.png" alt="image-20231225101526345"></p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s是给定的字符串，i是索引，res是结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> string s,<span class="type">int</span> i,string res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == s.<span class="built_in">size</span>())	<span class="comment">//超出索引，打印上一级传递的结果</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;空&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">print</span>(s,i + <span class="number">1</span>,res + s[i]);	<span class="comment">//添加当前字符</span></span><br><span class="line">		<span class="built_in">print</span>(s,i + <span class="number">1</span>,res );		<span class="comment">//丢弃当前字符</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、打印一个字符串的全部排列，要求不要出现重复的排列"><a href="#三、打印一个字符串的全部排列，要求不要出现重复的排列" class="headerlink" title="三、打印一个字符串的全部排列，要求不要出现重复的排列."></a>三、打印一个字符串的全部排列，要求不要出现重复的排列.</h3><ul>
<li>全排列是指，相同的字符，将字符放在不同顺序的排列。</li>
<li>每个位置尝试放字符串里的所有字符。</li>
</ul>
<h3 id="四、给定一个整型数组arr，代表数值不同的纸牌排成一条线。"><a href="#四、给定一个整型数组arr，代表数值不同的纸牌排成一条线。" class="headerlink" title="四、给定一个整型数组arr，代表数值不同的纸牌排成一条线。"></a>四、给定一个整型数组arr，代表数值不同的纸牌排成一条线。</h3><p>玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://haru-yuk1.github.io/MyBlog">HaruYuki</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://haru-yuk1.github.io/MyBlog/2024/10/08/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/">https://haru-yuk1.github.io/MyBlog/2024/10/08/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://haru-yuk1.github.io/MyBlog" target="_blank">春天的雪，静谧的诗</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/MyBlog/img/meguru.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/MyBlog/2024/10/12/test/" title="test"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">test</div></div></a><a class="next-post pull-right" href="/MyBlog/2024/10/08/Minecraft-%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/MyBlog/img/meguru.jpg" onerror="this.onerror=null;this.src='/MyBlog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">HaruYuki</div><div class="author-info-description">一个想要变得勤奋的人</div><div class="site-data"><a href="/MyBlog/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/MyBlog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/MyBlog/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">算法课程总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E5%8F%AF%E4%BB%A5%E7%90%86%E8%A7%A3%E4%B8%BA%E6%97%A0%E8%BF%9B%E4%BD%8D%E7%9B%B8%E5%8A%A0"><span class="toc-number">1.1.</span> <span class="toc-text">一、异或运算可以理解为无进位相加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">二、各种排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">基于比较的排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A-O-N-2-%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A-O-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.选择排序——时间复杂度：$O(N^2)$、空间复杂度：$O(1)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A-O-N-2-%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A-O-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.冒泡排序——时间复杂度：$O(N^2)$、空间复杂度：$O(1)$</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">冒泡排序的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">冒泡排序的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A-O-N-2-%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A-O-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">3.插入排序——时间复杂度：$O(N^2)$、空间复杂度：$O(1)$</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%94%B9%E8%BF%9B%EF%BC%9A%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">插入排序的改进：折半插入排序、希尔排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.5.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A-O-NlogN-%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A-O-N"><span class="toc-number">1.2.6.</span> <span class="toc-text">4.归并排序——时间复杂度：$O(NlogN)$、空间复杂度：$O(N)$</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Master-%E5%85%AC%E5%BC%8F-%E4%B8%80%E4%B8%AA%E9%80%92%E5%BD%92%EF%BC%8C%E6%AF%8D%E9%97%AE%E9%A2%98%E8%A7%84%E6%A8%A1%E4%B8%BAN%EF%BC%8C%E5%AD%90%E9%97%AE%E9%A2%98%E8%A7%84%E6%A8%A1%E9%83%BD%E4%B8%BAN-b-%EF%BC%9A"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">&#x3D;&#x3D;Master 公式(一个递归，母问题规模为N，子问题规模都为N&#x2F;b)：&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">归并排序的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.6.2.1.</span> <span class="toc-text">1.小和问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.6.2.2.</span> <span class="toc-text">2.逆序对问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A%E4%BC%98%E5%8C%96%E5%90%8E-O-NlogN-%EF%BC%8C%E6%9C%AA%E4%BC%98%E5%8C%96-O-N-2-%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A%E6%9C%80%E5%A5%BD%EF%BC%88%E7%9B%B8%E5%BD%93%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89-O-logN-%E6%9C%80%E5%B7%AE-O-N"><span class="toc-number">1.2.7.</span> <span class="toc-text">5.快速排序——时间复杂度：优化后$O(NlogN)$，未优化$O(N^2)$、空间复杂度：最好（相当于二叉树）$O(logN)$最差$O(N)$</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%B3%95-%E6%9C%80%E6%8E%A8%E8%8D%90%E7%94%A8%E8%BF%99%E7%A7%8D%E5%86%99%E6%B3%95"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">（1）前后指针法(最推荐用这种写法)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-hoare%E7%89%88%E6%9C%AC%E5%BF%AB%E6%8E%92%E2%80%94%E2%80%94%E5%AD%A6%E6%A0%A1%E7%94%A8%E7%9A%84%E8%BF%99%E4%B8%AA%E7%89%88%E6%9C%AC"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">(2)hoare版本快排——学校用的这个版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8C%96%E5%9D%91%E6%B3%95"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">(3)挖坑法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">快速排序的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%89%E6%95%B0%E5%8F%96%E4%B8%AD%E6%B3%95%E3%80%81%E9%9A%8F%E6%9C%BA%E9%80%89key%E6%B3%95%E2%80%94-%E9%9A%8F%E6%9C%BA%E4%B8%8E%E4%B8%89%E6%95%B0%E5%8F%96%E4%B8%AD%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%EF%BC%81"><span class="toc-number">1.2.7.4.1.</span> <span class="toc-text">1.三数取中法、随机选key法— 随机与三数取中性能比较！</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A0%86%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A-O-NlogN-%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A-O-1"><span class="toc-number">1.2.8.</span> <span class="toc-text">6.堆排序——时间复杂度：$O(NlogN)$、空间复杂度：$O(1)$</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%A0%86%EF%BC%88heap%EF%BC%89%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-priority-queue%EF%BC%89"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">前提知识——堆（heap）（优先队列-priority queue）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E5%A0%86%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">维护堆的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E5%A0%86"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">建堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E6%89%A9%E5%B1%95%E9%A2%98%E7%9B%AE"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">堆排序扩展题目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8D%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">1.2.9.</span> <span class="toc-text">线性时间排序（不基于比较的排序）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%A1%B6%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A%E6%9C%80%E5%A5%BD-O-N-K-%E6%9C%80%E5%9D%8F-O-N-2-%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-O-N-K"><span class="toc-number">1.2.10.</span> <span class="toc-text">7.桶排序——时间复杂度：最好$O(N+K)$ 最坏$O(N^2)$、空间复杂度$O(N+K)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-O-N-K-%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-O-N-K"><span class="toc-number">1.2.11.</span> <span class="toc-text">8.计数排序——时间复杂度$O(N+K)$、空间复杂度$O(N+K)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-O-N-times-K-%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-O-N-K"><span class="toc-number">1.2.12.</span> <span class="toc-text">9.基数排序——时间复杂度$O(N\times K)$、空间复杂度$O(N+K)$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.13.</span> <span class="toc-text">排序算法总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.14.</span> <span class="toc-text">比较器的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">三、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%A3%E5%88%97%E8%A1%A8-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.哈希表(散列表)的简单介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.有序表的简单介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E5%8D%95%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.3.3.0.1.</span> <span class="toc-text">2.1 单个节点的组成</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88C-%EF%BC%89"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">单向链表的代码实现（C++）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89%EF%BC%88struct%EF%BC%89"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">一、链表定义（struct）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%8A%82%E7%82%B9%E5%88%9B%E5%BB%BA"><span class="toc-number">1.3.3.1.2.</span> <span class="toc-text">二、节点创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">1.3.3.1.3.</span> <span class="toc-text">三、插入节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%BE%AA%E7%8E%AF%E5%BB%BA%E7%AB%8B%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.3.1.4.</span> <span class="toc-text">四、循环建立链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.3.1.5.</span> <span class="toc-text">五、遍历链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">1.3.3.1.6.</span> <span class="toc-text">六、删除节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">双向链表的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89%EF%BC%88struct%EF%BC%89-1"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">一、链表定义（struct）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%8A%82%E7%82%B9%E5%88%9B%E5%BB%BA-1"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">二、节点创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-1"><span class="toc-number">1.3.3.2.3.</span> <span class="toc-text">三、插入节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%BE%AA%E7%8E%AF%E5%BB%BA%E7%AB%8B%E9%93%BE%E8%A1%A8-1"><span class="toc-number">1.3.3.2.4.</span> <span class="toc-text">四、循环建立链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8-1"><span class="toc-number">1.3.3.2.5.</span> <span class="toc-text">五、遍历链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-1"><span class="toc-number">1.3.3.2.6.</span> <span class="toc-text">六、删除节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%B8%B8%E8%A7%81%E9%A2%98"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">链表常见题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8F%8D%E8%BD%AC%E5%8D%95%E5%90%91%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">一、反转单向和双向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%8F%8D%E8%BD%AC%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">1、反转单向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.3.3.5.1.</span> <span class="toc-text">1、迭代反转</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%A4%B4%E6%8F%92%E6%B3%95"><span class="toc-number">1.3.3.5.2.</span> <span class="toc-text">2、头插法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%B0%B1%E5%9C%B0%E9%80%86%E8%BD%AC%E6%B3%95"><span class="toc-number">1.3.3.5.3.</span> <span class="toc-text">3、就地逆转法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.3.3.5.4.</span> <span class="toc-text">4、递归反转</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%8F%8D%E8%BD%AC%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">2、反转双向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%89%93%E5%8D%B0%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E9%83%A8%E5%88%86"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">二、打印两个有序链表的公共部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.3.8.</span> <span class="toc-text">三、判断一个链表是否为回文结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B0%86%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%8C%89%E6%9F%90%E5%80%BC%E5%88%92%E5%88%86%E4%B8%BA%E5%B7%A6%E8%BE%B9%E5%B0%8F%E3%80%81%E4%B8%AD%E9%97%B4%E7%9B%B8%E7%AD%89%E3%80%81%E5%8F%B3%E8%BE%B9%E5%A4%A7%E7%9A%84%E5%BD%A2%E5%BC%8F%EF%BC%88%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">1.3.3.9.</span> <span class="toc-text">四、将单向链表按某值划分为左边小、中间相等、右边大的形式（分隔链表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%A4%8D%E5%88%B6%E5%90%AB%E6%9C%89%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.3.10.</span> <span class="toc-text">五、复制含有随机指针节点的链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.3.11.</span> <span class="toc-text">六、两个单链表相交的一系列问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.3.12.</span> <span class="toc-text">七、合并k个升序链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">四、栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.4.1.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.2.</span> <span class="toc-text">1、栈的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">2、栈的顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E6%A0%88"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">自己定义栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STL%E5%BA%93%E4%B8%AD%E7%9A%84%E6%A0%88"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">STL库中的栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.4.</span> <span class="toc-text">3、栈的链式存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.5.</span> <span class="toc-text">4、栈的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%80%92%E5%BD%92"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">一、递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">二、四则运算表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.4.6.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">1.队列的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">2.队列的顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97"><span class="toc-number">1.4.6.2.1.</span> <span class="toc-text">1、顺序队列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-STL%E5%BA%93%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">3.STL库中的队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">1.4.7.</span> <span class="toc-text">优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">一、定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">二、二叉堆</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.7.2.1.</span> <span class="toc-text">二叉堆的操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%8B%93%E5%B1%95"><span class="toc-number">1.4.7.3.</span> <span class="toc-text">堆的拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%8F%8C%E7%AB%AF%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">1.4.7.3.1.</span> <span class="toc-text">1、双端优先级队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%AF%B9%E9%A1%B6%E5%A0%86"><span class="toc-number">1.4.7.3.2.</span> <span class="toc-text">2、对顶堆</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.7.4.</span> <span class="toc-text">堆的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#K%E4%B8%AA%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0%E5%92%8C"><span class="toc-number">1.4.7.4.1.</span> <span class="toc-text">K个最小元素和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E9%A2%98"><span class="toc-number">1.4.8.</span> <span class="toc-text">栈和队列的题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">1.用栈实现队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">2.用队列实现栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">五、二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.5.1.</span> <span class="toc-text">一、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%80%A7%E8%B4%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">二、性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BD%A2%E6%80%81"><span class="toc-number">1.5.3.</span> <span class="toc-text">三、二叉树的形态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.4.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">1.顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">2.链式存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.5.</span> <span class="toc-text">二叉树的建立与操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.6.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%8C%E9%80%92%E5%BD%92%E5%BA%8F"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">深度优先遍历，递归序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-%E6%A0%B9%E5%B7%A6%E5%8F%B3"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">1. 先序遍历(根左右)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E5%B7%A6%E6%A0%B9%E5%8F%B3%EF%BC%89"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">2.中序遍历（左根右）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E5%B7%A6%E5%8F%B3%E6%A0%B9%EF%BC%89"><span class="toc-number">1.5.6.4.</span> <span class="toc-text">3.后序遍历（左右根）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%88%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97"><span class="toc-number">1.5.6.5.</span> <span class="toc-text">4.层次遍历（宽度优先遍历）：使用队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6%EF%BC%88%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%89"><span class="toc-number">1.5.6.5.1.</span> <span class="toc-text">求一颗二叉树的宽度（宽度优先遍历）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.6.6.</span> <span class="toc-text">二叉树遍历的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%A5%87%E5%81%B6%E6%95%B0%E2%85%A0"><span class="toc-number">1.5.6.6.1.</span> <span class="toc-text">1.奇偶数Ⅰ</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A5%87%E5%81%B6%E6%A0%91%E2%85%A1"><span class="toc-number">1.5.6.6.2.</span> <span class="toc-text">2.奇偶树Ⅱ</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">1.5.7.</span> <span class="toc-text">二叉树的判断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86or%E6%A0%91%E5%9E%8Bdp"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">1.判断是否是搜索二叉树——中序遍历or树型dp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">2.判断是否是完全二叉树——宽度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.7.3.</span> <span class="toc-text">3.判断是否是满二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%E6%A0%91%E5%9E%8Bdp%E6%B1%82%E8%A7%A3"><span class="toc-number">1.5.7.4.</span> <span class="toc-text">4.判断是否是平衡二叉树——利用树型dp求解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%89"><span class="toc-number">1.5.8.</span> <span class="toc-text">四、最优二叉树（哈夫曼树）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.5.8.1.</span> <span class="toc-text">最优二叉树的性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A2%98"><span class="toc-number">1.5.9.</span> <span class="toc-text">二叉树的一些题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9node1%E5%92%8Cnode2%EF%BC%8C%E6%89%BE%E5%88%B0%E4%BB%96%E4%BB%AC%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9"><span class="toc-number">1.5.9.1.</span> <span class="toc-text">1.给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9"><span class="toc-number">1.5.9.2.</span> <span class="toc-text">2.在二叉树中找到一个节点的后继节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="toc-number">1.5.9.3.</span> <span class="toc-text">3.表达式树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.5.9.4.</span> <span class="toc-text">4.二叉树的序列化和反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.9.5.</span> <span class="toc-text">5.折纸问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8B%93%E5%B1%95"><span class="toc-number">1.5.10.</span> <span class="toc-text">二叉树拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.10.1.</span> <span class="toc-text">1.树的存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%88%B6%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.5.10.1.1.</span> <span class="toc-text">父亲表示法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">1.5.10.2.</span> <span class="toc-text">前缀树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%9B%BE"><span class="toc-number">1.6.</span> <span class="toc-text">六、图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">图的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">一、图的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.6.3.</span> <span class="toc-text">二、图的基本概念和术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">1、有向图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">2、无向图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.4.</span> <span class="toc-text">三、图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">一、邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">二、邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">三、十字链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">四、邻接多重表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.4.5.</span> <span class="toc-text">五、边集数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AD%98%E5%82%A8%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.6.4.6.</span> <span class="toc-text">六、存储模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.5.</span> <span class="toc-text">四、图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">1.宽度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">2.深度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.6.</span> <span class="toc-text">五、拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.6.7.</span> <span class="toc-text">六、最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%99%AE%E9%87%8C%E5%A7%86-Prim-%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.7.1.</span> <span class="toc-text">1. 普里姆(Prim)算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%88Kruskal%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.7.2.</span> <span class="toc-text">2.克鲁斯卡尔（Kruskal）算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.8.</span> <span class="toc-text">七、最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89-Dijkstra-%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.8.1.</span> <span class="toc-text">1. 迪杰斯特拉( Dijkstra )算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">七、贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">一、概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.2.</span> <span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%9A%E8%AE%AE%E5%AE%89%E6%8E%92"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">1.会议安排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">题目分析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">2.字符串拼接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90%EF%BC%9A-1"><span class="toc-number">1.7.3.</span> <span class="toc-text">题目分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%87%91%E6%9D%A1%E5%88%87%E5%88%86"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">3.金条切分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">1.7.4.</span> <span class="toc-text">思路：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.</span> <span class="toc-text">八、查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.1.</span> <span class="toc-text">一、查找的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.2.</span> <span class="toc-text">二、顺序表查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">2.算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.3.</span> <span class="toc-text">三、顺序查找的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">1.查找最大值和最小值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4%E5%86%85%E6%89%80%E6%9C%89%E8%B4%A8%E6%95%B0"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">2.查找区间内所有质数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AF%95%E9%99%A4%E6%B3%95-%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-O-n-sqrt-n"><span class="toc-number">1.8.3.2.1.</span> <span class="toc-text">(1).试除法 ——时间复杂度$O(n\sqrt n)$</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9F%83%E6%B0%8F%E7%AD%9B%E9%80%89%E6%B3%95%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-O-nloglog-n"><span class="toc-number">1.8.3.2.2.</span> <span class="toc-text">(2)埃氏筛选法——时间复杂度:O(nloglog(n))</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%90%88%E6%95%B0%E9%99%90%E5%AE%9A%E6%B3%95%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9AO-n"><span class="toc-number">1.8.3.2.3.</span> <span class="toc-text">(3)合数限定法——时间复杂度：O(n)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%AC%A7%E6%8B%89%E7%AD%9B%E9%80%89%E6%B3%95%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-O-n"><span class="toc-number">1.8.3.2.4.</span> <span class="toc-text">(4)欧拉筛选法——时间复杂度:O(n)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.4.</span> <span class="toc-text">四、有序表查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">1.折半查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">2.二分查找的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.8.4.2.1.</span> <span class="toc-text">1.区间查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BF%AB%E9%80%9F%E6%B1%82%E5%B9%82"><span class="toc-number">1.8.4.2.2.</span> <span class="toc-text">2.快速求幂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.4.2.3.</span> <span class="toc-text">3.快速查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.5.</span> <span class="toc-text">五、线性索引查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.6.</span> <span class="toc-text">六、动态查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%89"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">一、二叉排序树（二叉查找树）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.6.1.1.</span> <span class="toc-text">1. 二叉排序树的查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">1.8.6.1.2.</span> <span class="toc-text">2. 二叉排序树的插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">1.8.6.1.3.</span> <span class="toc-text">3. 二叉排序树的删除</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL%E6%A0%91"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">二、平衡二叉树(AVL树)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.8.6.2.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">1.8.6.2.2.</span> <span class="toc-text">2.平衡二叉树的查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">1.8.6.2.3.</span> <span class="toc-text">3.平衡二叉树的插入和删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-number">1.8.7.</span> <span class="toc-text">散列表查找（哈希表）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.7.1.</span> <span class="toc-text">一、散列表查找的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.7.2.</span> <span class="toc-text">二、散列函数的构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">1.8.7.2.1.</span> <span class="toc-text">1、直接定址法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">1.8.7.2.2.</span> <span class="toc-text">2、数字分析法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95"><span class="toc-number">1.8.7.2.3.</span> <span class="toc-text">3、平方取中法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E6%8A%98%E5%8F%A0%E6%B3%95"><span class="toc-number">1.8.7.2.4.</span> <span class="toc-text">4、折叠法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95"><span class="toc-number">1.8.7.2.5.</span> <span class="toc-text">5、除留余数法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%B3%95"><span class="toc-number">1.8.7.2.6.</span> <span class="toc-text">6、随机数法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A4%84%E7%90%86%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81"><span class="toc-number">1.8.7.3.</span> <span class="toc-text">三、处理散列冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="toc-number">1.8.7.3.1.</span> <span class="toc-text">1、开放地址法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%86%8D%E6%95%A3%E5%88%97%E6%B3%95"><span class="toc-number">1.8.7.3.2.</span> <span class="toc-text">2、再散列法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.7.4.</span> <span class="toc-text">四、散列表查找算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92"><span class="toc-number">1.9.</span> <span class="toc-text">九、暴力递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.1.</span> <span class="toc-text">一、汉诺塔问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%89%93%E5%8D%B0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E9%83%A8%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E5%AD%90%E9%9B%86%EF%BC%89%EF%BC%8C%E5%8C%85%E6%8B%AC%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.9.2.</span> <span class="toc-text">二、打印一个字符串的全部子序列（子集），包括空字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%89%93%E5%8D%B0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E9%83%A8%E6%8E%92%E5%88%97%EF%BC%8C%E8%A6%81%E6%B1%82%E4%B8%8D%E8%A6%81%E5%87%BA%E7%8E%B0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">1.9.3.</span> <span class="toc-text">三、打印一个字符串的全部排列，要求不要出现重复的排列.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B4%E5%9E%8B%E6%95%B0%E7%BB%84arr%EF%BC%8C%E4%BB%A3%E8%A1%A8%E6%95%B0%E5%80%BC%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BA%B8%E7%89%8C%E6%8E%92%E6%88%90%E4%B8%80%E6%9D%A1%E7%BA%BF%E3%80%82"><span class="toc-number">1.9.4.</span> <span class="toc-text">四、给定一个整型数组arr，代表数值不同的纸牌排成一条线。</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/MyBlog/2024/10/12/test/" title="test">test</a><time datetime="2024-10-12T07:44:54.000Z" title="发表于 2024-10-12 15:44:54">2024-10-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/MyBlog/2024/10/08/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/" title="无标题">无标题</a><time datetime="2024-10-08T13:25:41.523Z" title="发表于 2024-10-08 21:25:41">2024-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/MyBlog/2024/10/08/Minecraft-%E6%A8%A1%E7%BB%84%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" title="无标题">无标题</a><time datetime="2024-10-08T13:23:37.588Z" title="发表于 2024-10-08 21:23:37">2024-10-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By HaruYuki</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/MyBlog/js/utils.js"></script><script src="/MyBlog/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>